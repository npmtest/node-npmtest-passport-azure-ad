{"/home/travis/build/npmtest/node-npmtest-passport-azure-ad/test.js":"/* istanbul instrument in package npmtest_passport_azure_ad */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/lib.npmtest_passport_azure_ad.js":"/* istanbul instrument in package npmtest_passport_azure_ad */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_passport_azure_ad = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_passport_azure_ad = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-passport-azure-ad && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_passport_azure_ad */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_passport_azure_ad\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_passport_azure_ad.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_passport_azure_ad.rollup.js'] =\n            local.assetsDict['/assets.npmtest_passport_azure_ad.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_passport_azure_ad.__dirname + '/lib.npmtest_passport_azure_ad.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/index.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the 'Software'), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n'use strict';\r\n\r\n/**\r\n * Export BearerStrategy and OIDCStrategy.\r\n */\r\nmodule.exports.BearerStrategy = require('./bearerstrategy');\r\nmodule.exports.OIDCStrategy = require('./oidcstrategy');\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/bearerstrategy.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the 'Software'), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n'use strict';\r\n\r\n/* eslint no-underscore-dangle: 0 */\r\n\r\nconst async = require('async');\r\nconst cacheManager = require('cache-manager');\r\nconst jws = require('jws');\r\nconst passport = require('passport');\r\nconst util = require('util');\r\n\r\nconst aadutils = require('./aadutils');\r\nconst CONSTANTS = require('./constants');\r\nconst jwt = require('./jsonWebToken');\r\nconst Metadata = require('./metadata').Metadata;\r\nconst Log = require('./logging').getLogger;\r\nconst UrlValidator = require('valid-url');\r\n\r\nconst log = new Log('AzureAD: Bearer Strategy');\r\nconst memoryCache = cacheManager.caching({ store: 'memory', max: 3600, ttl: 1800 /* seconds */ });\r\nconst ttl = 1800; // 30 minutes cache\r\n\r\nconst B2C_PREFIX = 'b2c_1_';\r\n\r\n/**\r\n * Applications must supply a `verify` callback, for which the function\r\n * signature is:\r\n *\r\n *     function(token, done) { ... }\r\n * or\r\n *     function(req, token, done) { ... }\r\n *\r\n * The latter enables you to use the request object. In order to use this\r\n * signature, the passReqToCallback value in options (see the Options instructions\r\n * below) must be set true, so the strategy knows you want to pass the request\r\n * to the `verify` callback function.\r\n *\r\n * `token` is the verified and decoded bearer token provided as a credential.\r\n * The verify callback is responsible for finding the user who posesses the\r\n * token, and invoking `done` with the following arguments:\r\n *\r\n *     done(err, user, info);\r\n *\r\n * If the token is not valid, `user` should be set to `false` to indicate an\r\n * authentication failure.  Additional token `info` can optionally be passed as\r\n * a third argument, which will be set by Passport at `req.authInfo`, where it\r\n * can be used by later middleware for access control.  This is typically used\r\n * to pass any scope associated with the token.\r\n * \r\n *\r\n * Options:\r\n *\r\n *   - `identityMetadata`   (1) Required\r\n *                          (2) must be a https url string\r\n *                          (3) Description:\r\n *                          the metadata endpoint provided by the Microsoft Identity Portal that provides \r\n *                          the keys and other important info at runtime. Examples:\r\n *                          <1> v1 tenant-specific endpoint\r\n *                          - https://login.microsoftonline.com/your_tenant_name.onmicrosoft.com/.well-known/openid-configuration\r\n *                          - https://login.microsoftonline.com/your_tenant_guid/.well-known/openid-configuration\r\n *                          <2> v1 common endpoint\r\n *                          - https://login.microsoftonline.com/common/.well-known/openid-configuration\r\n *                          <3> v2 tenant-specific endpoint\r\n *                          - https://login.microsoftonline.com/your_tenant_name.onmicrosoft.com/v2.0/.well-known/openid-configuration\r\n *                          - https://login.microsoftonline.com/your_tenant_guid/v2.0/.well-known/openid-configuration\r\n *                          <4> v2 common endpoint\r\n *                          - https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration\r\n *                         \r\n *                          Note: you cannot use common endpoint for B2C\r\n *\r\n *   - `clientID`           (1) Required\r\n *                          (2) must be a string\r\n *                          (3) Description:\r\n *                          The Client ID of your app in AAD\r\n *\r\n *   - `validateIssuer`     (1) Required to set to false if you don't want to validate issuer, default value is true\r\n *                          (2) Description:\r\n *                          For common endpoint, you should either set `validateIssuer` to false, or provide the `issuer`, since\r\n *                          we cannot grab the `issuer` value from metadata.\r\n *                          For non-common endpoint, we use the `issuer` from metadata, and `validateIssuer` should be always true\r\n *\r\n *   - `issuer`             (1) Required if you are using common endpoint and set `validateIssuer` to true, or if you want to specify the allowed issuers\r\n *                          (2) must be a string or an array of strings\r\n *                          (3) Description:\r\n *                          For common endpoint, we use the `issuer` provided.\r\n *                          For non-common endpoint, if the `issuer` is not provided, we use the issuer provided by metadata\r\n *\r\n *   - `passReqToCallback`  (1) Required to set true if you want to use the `function(req, token, done)` signature for the verify function, default is false\r\n *                          (2) Description:\r\n *                          Set `passReqToCallback` to true use the `function(req, token, done)` signature for the verify function\r\n *                          Set `passReqToCallback` to false use the `function(token, done)` signature for the verify function \r\n *\r\n *   - `isB2C`              (1) Required to set to true for using B2C, default value is false\r\n *                          \r\n *   - `policyName`         (1) Required for using B2C\r\n *                          (2) Description:\r\n *                          policy name. Should be a string starting with 'B2C_1_' (case insensitive)\r\n *\r\n *\r\n *   - `allowMultiAudiencesInToken`\r\n *                          (1) Required if you allow access_token whose `aud` claim contains multiple values\r\n *                          (2) Description:\r\n *                          The default value is false \r\n *\r\n *   - `loggingLevel`       (1) Optional\r\n *                          (2) must be 'info', 'warn', 'error'\r\n *                          (3) Description:  \r\n *                          logging level \r\n *\r\n *   - `audience`           (1) Optional\r\n *                          (2) must be a string or an array of strings\r\n *                          (3) Description:\r\n *                          We invalidate the `aud` claim in access_token against `audience`. The default value is `clientID` \r\n *\r\n *   - `clockSkew`          (1) Optional\r\n *                          (2) must be a positive integer\r\n *                          (3) Description:\r\n *                          the clock skew (in seconds) allowed in token validation, default value is CLOCK_SKEW\r\n * Examples:\r\n *\r\n *     passport.use(new BearerStrategy(\r\n *       options,\r\n *       function(token, done) {\r\n *         User.findById(token.sub, function (err, user) {\r\n *           if (err) { return done(err); }\r\n *           if (!user) { return done(null, false); }\r\n *           return done(null, user, token);\r\n *         });\r\n *       }\r\n *     ));\r\n *\r\n * The name of this strategy is 'oauth-bearer', so use this name as the first \r\n * parameter of the authenticate function. Moreover, we don't need session \r\n * support for request containing bearer tokens, so the session option can be\r\n * set to false.\r\n * \r\n *     app.get('/protected_resource', \r\n *       passport.authenticate('oauth-bearer', {session: false}), \r\n *       function(req, res) { \r\n *         ... \r\n *       });\r\n *\r\n *\r\n * For further details on HTTP Bearer authentication, refer to [The OAuth 2.0 Authorization Protocol: Bearer Tokens]\r\n * (http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer)\r\n * For further details on JSON Web Token, refert to [JSON Web Token](http://tools.ietf.org/html/draft-ietf-oauth-json-web-token)\r\n *\r\n * @param {object} options - The Options.\r\n * @param {Function} verify - The verify callback.\r\n * @constructor\r\n */\r\nfunction Strategy(options, verifyFn) {\r\n  passport.Strategy.call(this);\r\n  this.name = 'oauth-bearer'; // Me, a name I call myself.\r\n\r\n  if (!options)\r\n    throw new Error('In BearerStrategy constructor: options is required');\r\n  if (!verifyFn || typeof verifyFn !== 'function')\r\n    throw new Error('In BearerStrategy constructor: verifyFn is required and it must be a function');\r\n\r\n  this._verify = verifyFn;\r\n  this._options = options;\r\n\r\n  //---------------------------------------------------------------------------\r\n  // Set up the default values\r\n  //---------------------------------------------------------------------------\r\n\r\n  // clock skew. Must be a postive integer\r\n  if (options.clockSkew && (typeof options.clockSkew !== 'number' || options.clockSkew <= 0 || options.clockSkew % 1 !== 0))\r\n    throw new Error('clockSkew must be a positive integer');\r\n  if (!options.clockSkew)\r\n    options.clockSkew = CONSTANTS.CLOCK_SKEW;\r\n\r\n  // default value of passReqToCallback is false\r\n  if (options.passReqToCallback !== true)\r\n    options.passReqToCallback = false;\r\n\r\n  // default value of validateIssuer is true \r\n  if (options.validateIssuer !== false) \r\n    options.validateIssuer = true;\r\n\r\n  // default value of allowMultiAudiencesInToken is false\r\n  if (options.allowMultiAudiencesInToken !== true)\r\n    options.allowMultiAudiencesInToken = false;\r\n\r\n  // if options.audience is a string or an array of string, then we use it;\r\n  // otherwise we use the clientID\r\n  if (options.audience && typeof options.audience === 'string')\r\n    options.audience = [options.audience];\r\n  else if (!options.audience || !Array.isArray(options.audience) || options.length === 0)\r\n    options.audience = [options.clientID, 'spn:' + options.clientID];\r\n\r\n  // default value of isB2C is false\r\n  if (options.isB2C !== true)\r\n    options.isB2C = false;\r\n\r\n  // turn issuer into an array\r\n  if (options.issuer === '')\r\n    options.issuer = null;\r\n  if (options.issuer && Array.isArray(options.issuer) && options.issuer.length === 0)\r\n    options.issuer = null; \r\n  if (options.issuer && !Array.isArray(options.issuer))\r\n    options.issuer = [options.issuer];\r\n\r\n  //---------------------------------------------------------------------------\r\n  // validate the things in options\r\n  //---------------------------------------------------------------------------\r\n\r\n  // clientID should not be empty\r\n  if (!options.clientID || options.clientID === '')\r\n    throw new Error('In BearerStrategy constructor: clientID cannot be empty');\r\n\r\n  // identityMetadata must be https url\r\n  if (!options.identityMetadata || !UrlValidator.isHttpsUri(options.identityMetadata))\r\n    throw new Error('In BearerStrategy constructor: identityMetadata must be provided and must be a https url');\r\n\r\n  //---------------------------------------------------------------------------\r\n  // treatment of common endpoint and issuer\r\n  //---------------------------------------------------------------------------\r\n\r\n  // check if we are using the common endpoint\r\n  options._isCommonEndpoint = (options.identityMetadata.indexOf('/common/') != -1);\r\n\r\n  // issuer validation for common endpoint is not supported\r\n  if (options._isCommonEndpoint && options.validateIssuer && !options.issuer)\r\n    throw new Error(`In BearerStrategy constructor: you are using common endpoint, please either set 'validateIssuer' to false, or provide 'issuer' value in options`);\r\n\r\n  // give a warning if user is not validating issuer\r\n  if (!options.validateIssuer)\r\n    log.warn(`Production environments should always validate the issuer.`);\r\n\r\n  //---------------------------------------------------------------------------\r\n  // B2C. \r\n  // (1) policy must be provided and must have the valid prefix\r\n  // (2) common endpoint is not supported\r\n  //---------------------------------------------------------------------------\r\n\r\n  // for B2C, \r\n  if (options.isB2C) {\r\n    if (!options.policyName || !options.policyName.toLowerCase().startsWith(B2C_PREFIX))\r\n      throw new Error('In BearerStrategy constructor: invalid policy for B2C');\r\n    if (options._isCommonEndpoint)\r\n      throw new Error(`In BearerStrategy constructor: common endpoint is not supported for B2C, please replace 'common' with your tenant name or tenant guid in 'identityMetadata'`);\r\n  }\r\n\r\n  // if logging level specified, switch to it.\r\n  if (options.loggingLevel) { log.levels('console', options.loggingLevel); }\r\n\r\n  log.info(`In BearerStrategy constructor: created strategy with options ${JSON.stringify(options)}`);\r\n}\r\n\r\nutil.inherits(Strategy, passport.Strategy);\r\n\r\nStrategy.prototype.jwtVerify = function jwtVerifyFunc(req, token, metadata, optionsToValidate, done) {\r\n  const self = this;\r\n\r\n  const decoded = jws.decode(token);\r\n  let PEMkey = null;\r\n\r\n  if (decoded == null) {\r\n    return done(null, false, 'In Strategy.prototype.jwtVerify: Invalid JWT token.');\r\n  }\r\n\r\n  log.info('In Strategy.prototype.jwtVerify: token decoded:  ', decoded);\r\n\r\n  // When we generate the PEMkey, there are two different types of token signatures\r\n  // we have to validate here. One provides x5t and the other a kid. We need to call \r\n  // the right one.\r\n  if (decoded.header.x5t) {\r\n    PEMkey = metadata.generateOidcPEM(decoded.header.x5t);\r\n  } else if (decoded.header.kid) {\r\n    PEMkey = metadata.generateOidcPEM(decoded.header.kid);\r\n  } else {\r\n    return self.failWithLog('In Strategy.prototype.jwtVerify: We did not receive a token we know how to validate');\r\n  }\r\n\r\n  log.info('PEMkey generated: ' + PEMkey);\r\n\r\n  jwt.verify(token, PEMkey, optionsToValidate, (err, verifiedToken) => {\r\n    if (err) {\r\n      if (err.message)\r\n        return self.failWithLog(err.message);\r\n      else\r\n        return self.failWithLog('In Strategy.prototype.jwtVerify: cannot verify id token');\r\n    }\r\n\r\n    log.info('In Strategy.prototype.jwtVerify: VerifiedToken: ', verifiedToken);\r\n    \r\n    if (self._options.passReqToCallback) {\r\n      log.info('In Strategy.prototype.jwtVerify: We did pass Req back to Callback');\r\n      return self._verify(req, verifiedToken, done);\r\n    } else {\r\n      log.info('In Strategy.prototype.jwtVerify: We did not pass Req back to Callback');\r\n      return self._verify(verifiedToken, done);\r\n    }\r\n  });\r\n};\r\n\r\n/*\r\n * We let the metadata loading happen in `authenticate` function, and use waterfall\r\n * to make sure the authentication code runs after the metadata loading is finished.\r\n */\r\nStrategy.prototype.authenticate = function authenticateStrategy(req) {\r\n  const self = this;\r\n  var params = {};\r\n  var optionsToValidate = {};\r\n\r\n  /* Some introduction to async.waterfall (from the following link):\r\n   * http://stackoverflow.com/questions/28908180/what-is-a-simple-implementation-of-async-waterfall\r\n   *\r\n   *   Runs the tasks array of functions in series, each passing their results \r\n   * to the next in the array. However, if any of the tasks pass an error to \r\n   * their own callback, the next function is not executed, and the main callback\r\n   * is immediately called with the error.\r\n   *\r\n   * Example:\r\n   *\r\n   * async.waterfall([\r\n   *   function(callback) {\r\n   *     callback(null, 'one', 'two');\r\n   *   },\r\n   *   function(arg1, arg2, callback) {\r\n   *     // arg1 now equals 'one' and arg2 now equals 'two'\r\n   *     callback(null, 'three');\r\n   *   },\r\n   *   function(arg1, callback) {\r\n   *     // arg1 now equals 'three'\r\n   *     callback(null, 'done');\r\n   *   }\r\n   * ], function (err, result) {\r\n   *      // result now equals 'done'    \r\n   * }); \r\n   */\r\n  async.waterfall([\r\n\r\n    // compute metadataUrl\r\n    (next) => {\r\n      params.metadataURL = self._options.identityMetadata\r\n            .concat(`?${aadutils.getLibraryProductParameterName()}=${aadutils.getLibraryProduct()}`)\r\n            .concat(`&${aadutils.getLibraryVersionParameterName()}=${aadutils.getLibraryVersion()}`); ;\r\n\r\n      if (self._options.isB2C)\r\n        params.metadataURL = params.metadataURL.concat(`&p=${self._options.policyName}`)\r\n\r\n      params.cacheKey = params.metadataURL;\r\n\r\n      log.info(`In Strategy.prototype.authenticate: ${JSON.stringify(params)}`);\r\n\r\n      return next(null, params);\r\n    },\r\n    \r\n    // load metatadata\r\n    (params, next) => {\r\n      return self.loadMetadata(params, next);\r\n    },\r\n\r\n    // configure using metadata\r\n    (metadata, next) => {\r\n      params.metadata = metadata;\r\n      log.info(`In Strategy.prototype.authenticate: received metadata: ${JSON.stringify(metadata)}`);\r\n\r\n      // set up issuer\r\n      if (self._options.validateIssuer && !self._options.issuer)\r\n        optionsToValidate.issuer = metadata.oidc.issuer;\r\n      else\r\n        optionsToValidate.issuer = self._options.issuer;\r\n\r\n      // set up algorithm\r\n      optionsToValidate.algorithms = metadata.oidc.algorithms;\r\n\r\n      // set up audience, validateIssuer, allowMultiAudiencesInToken\r\n      optionsToValidate.audience = self._options.audience;\r\n      optionsToValidate.validateIssuer = self._options.validateIssuer;\r\n      optionsToValidate.allowMultiAudiencesInToken = self._options.allowMultiAudiencesInToken;\r\n      optionsToValidate.ignoreExpiration = self._options.ignoreExpiration;\r\n\r\n      // clock skew\r\n      optionsToValidate.clockSkew = self._options.clockSkew;\r\n\r\n      log.info(`In Strategy.prototype.authenticate: we will validate the following options: ${optionsToValidate}`);\r\n\r\n      return next();\r\n    }, \r\n\r\n    // extract the access token from the request, after getting the token, it \r\n    // will call `jwtVerify` to verify the token. If token is verified, `jwtVerify`\r\n    // will provide the token payload to self._verify function. self._verify is\r\n    // provided by the developer, it's up to the developer to decide if the token\r\n    // payload is considered authenticated. If authenticated, self._verify will\r\n    // provide `user` object (developer's decision of its content) to `verified` \r\n    // function here, and the `verified` function does the final work of stuffing\r\n    // the `user` obejct into req.user, so the following middleware can use it.\r\n    // This is basically how bearerStrategy works.\r\n    (next) => {\r\n      var token;\r\n\r\n      // token could be in header or body. query is not supported.\r\n\r\n      if (req.query && req.query.access_token)\r\n        return self.failWithLog('In Strategy.prototype.authenticate: access_token should be passed in request header or body. query is unsupported');\r\n\r\n      if (req.headers && req.headers.authorization) {\r\n        var auth_components = req.headers.authorization.split(' ');\r\n        if (auth_components.length == 2 &&auth_components[0].toLowerCase() === 'bearer') {\r\n            token = auth_components[1];\r\n            if (token !== '')\r\n              log.info('In Strategy.prototype.authenticate: received access_token from request header: ${token}');\r\n            else\r\n              self.failWithLog('In Strategy.prototype.authenticate: missing access_token in the header');\r\n        }\r\n      }\r\n\r\n      if (req.body && req.body.access_token) {\r\n        if (token)\r\n          return self.failWithLog('In Strategy.prototype.authenticate: access_token cannot be passed in both request header and body');\r\n        token = req.body.access_token;\r\n        if (token)\r\n          log.info(`In Strategy.prototype.authenticate: received access_token from request body: ${token}`);\r\n      }\r\n\r\n      if (!token)\r\n        return self.failWithLog('token is not found'); \r\n\r\n      function verified(err, user, info) {\r\n        if (err)\r\n          return self.error(err);\r\n\r\n        if (!user) {\r\n          var err_message = 'error: invalid_token';\r\n          if (info && typeof info == 'string')\r\n            err_message += ', error description: ' + info;\r\n          else if (info)\r\n            err_message += ', error description: ' + JSON.stringify(info);\r\n          return self.failWithLog(err_message);\r\n        }\r\n\r\n        return self.success(user, info);\r\n      }\r\n\r\n      return self.jwtVerify(req, token, params.metadata, optionsToValidate, verified);\r\n    }],\r\n\r\n    (waterfallError) => { // This function gets called after the three tasks have called their 'task callbacks'\r\n      if (waterfallError) {\r\n        return self.error(waterfallError);\r\n      }\r\n      return true;\r\n    }\r\n  );\r\n};\r\n\r\nStrategy.prototype.loadMetadata = function(params, next) {\r\n  const self = this;\r\n  var metadata = new Metadata(params.metadataURL, 'oidc', self._options);\r\n\r\n  // fetch metadata\r\n  return memoryCache.wrap(params.cacheKey, (cacheCallback) => {\r\n    metadata.fetch((fetchMetadataError) => {\r\n      if (fetchMetadataError) {\r\n        return self.failWithLog('In loadMetadata: Unable to fetch metadata');\r\n      }\r\n      return cacheCallback(null, metadata);\r\n    }); \r\n  }, { ttl }, next);\r\n};\r\n\r\n/**\r\n * fail and log the given message\r\n *\r\n * @params {String} message\r\n */\r\nStrategy.prototype.failWithLog = function(message) {\r\n  log.info(`authentication failed due to: ${message}`);\r\n  return this.fail(message);\r\n};\r\n\r\nmodule.exports = Strategy;\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/aadutils.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n'use strict';\r\n\r\nconst base64url = require('base64url');\r\nconst crypto = require('crypto');\r\nconst util = require('util');\r\n\r\nexports.getLibraryProduct = () => { return 'passport-azure-ad' };\r\nexports.getLibraryVersionParameterName = () => { return \"x-client-Ver\" };\r\nexports.getLibraryProductParameterName = () => { return 'x-client-SKU' };\r\nexports.getLibraryVersion = () => { \r\n  require('pkginfo')(module, 'version');\r\n  return module.exports.version;\r\n};\r\n\r\nexports.getElement = (parentElement, elementName) => {\r\n  if (parentElement[`saml:${elementName}`]) {\r\n    return parentElement[`saml:${elementName}`];\r\n  } else if (parentElement[`samlp:${elementName}`]) {\r\n    return parentElement[`samlp:${elementName}`];\r\n  } else if (parentElement[`wsa:${elementName}`]) {\r\n    return parentElement[`wsa:${elementName}`];\r\n  }\r\n  return parentElement[elementName];\r\n};\r\n\r\nexports.getFirstElement = (parentElement, elementName) => {\r\n  const element = exports.getElement(parentElement, elementName);\r\n  return Array.isArray(element) ? element[0] : element;\r\n};\r\n\r\n/**\r\n * Reconstructs the original URL of the request.\r\n *\r\n * This function builds a URL that corresponds the original URL requested by the\r\n * client, including the protocol (http or https) and host.\r\n *\r\n * If the request passed through any proxies that terminate SSL, the\r\n * `X-Forwarded-Proto` header is used to detect if the request was encrypted to\r\n * the proxy.\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\nexports.originalURL = (req) => {\r\n  const headers = req.headers;\r\n  const protocol = (req.connection.encrypted || req.headers['x-forwarded-proto'] === 'https') ? 'https' : 'http';\r\n  const host = headers.host;\r\n  const path = req.url || '';\r\n  return `${protocol}://${host}${path}`;\r\n};\r\n\r\n/**\r\n * Merge object b with object a.\r\n *\r\n *     var a = { something: 'bar' }\r\n *       , b = { bar: 'baz' };\r\n *\r\n *     utils.merge(a, b);\r\n *     // => { something: 'bar', bar: 'baz' }\r\n *\r\n * @param {Object} a\r\n * @param {Object} b\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nexports.merge = (a, b) => {\r\n  return util._extend(a, b); // eslint-disable-line no-underscore-dangle\r\n};\r\n\r\n/**\r\n * Return a unique identifier with the given `len`.\r\n *\r\n *     utils.uid(10);\r\n *     // => \"FDaS435D2z\"\r\n *\r\n * CREDIT: Connect -- utils.uid\r\n *         https://github.com/senchalabs/connect/blob/2.7.2/lib/utils.js\r\n *\r\n * @param {Number} len\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.uid = (len) => {\r\n  return crypto.randomBytes(Math.ceil(len * 3 / 4))\r\n    .toString('base64')\r\n    .slice(0, len);\r\n};\r\n\r\nfunction prepadSigned(hexStr) {\r\n  const msb = hexStr[0];\r\n  if (msb < '0' || msb > '7') {\r\n    return `00${hexStr}`;\r\n  }\r\n  return hexStr;\r\n}\r\n\r\nfunction toHex(number) {\r\n  const nstr = number.toString(16);\r\n  if (nstr.length % 2) {\r\n    return `0${nstr}`;\r\n  }\r\n  return nstr;\r\n}\r\n\r\n// encode ASN.1 DER length field\r\n// if <=127, short form\r\n// if >=128, long form\r\nfunction encodeLengthHex(n) {\r\n  if (n <= 127) {\r\n    return toHex(n);\r\n  }\r\n  const nHex = toHex(n);\r\n  const lengthOfLengthByte = 128 + nHex.length / 2; // 0x80+numbytes\r\n  return toHex(lengthOfLengthByte) + nHex;\r\n}\r\n\r\n// http://stackoverflow.com/questions/18835132/xml-to-pem-in-node-js\r\nexports.rsaPublicKeyPem = (modulusB64, exponentB64) => {\r\n  const modulus = new Buffer(modulusB64, 'base64');\r\n  const exponent = new Buffer(exponentB64, 'base64');\r\n\r\n  const modulusHex = prepadSigned(modulus.toString('hex'));\r\n  const exponentHex = prepadSigned(exponent.toString('hex'));\r\n\r\n  const modlen = modulusHex.length / 2;\r\n  const explen = exponentHex.length / 2;\r\n\r\n  const encodedModlen = encodeLengthHex(modlen);\r\n  const encodedExplen = encodeLengthHex(explen);\r\n  const encodedPubkey = `30${encodeLengthHex(\r\n          modlen +\r\n          explen +\r\n          encodedModlen.length / 2 +\r\n          encodedExplen.length / 2 + 2\r\n        )}02${encodedModlen}${modulusHex}02${encodedExplen}${exponentHex}`;\r\n\r\n  const derB64 = new Buffer(encodedPubkey, 'hex').toString('base64');\r\n\r\n  const pem = `-----BEGIN RSA PUBLIC KEY-----\\n${derB64.match(/.{1,64}/g).join('\\n')}\\n-----END RSA PUBLIC KEY-----\\n`;\r\n\r\n  return pem;\r\n};\r\n\r\n// used for c_hash and at_hash validation\r\n// case (1): content = access_token, hashProvided = at_hash\r\n// case (2): content = code, hashProvided = c_hash\r\nexports.checkHashValueRS256 = (content, hashProvided) => {\r\n  if (!content)\r\n    return false;\r\n  \r\n  // step 1. hash the content\r\n  var digest = crypto.createHash('sha256').update(content, 'ascii').digest();\r\n\r\n  // step2. take the first half of the digest, and save it in a buffer\r\n  var buffer = new Buffer(digest.length/2);\r\n  for (var i = 0; i < buffer.length; i++)\r\n    buffer[i] = digest[i];\r\n\r\n  // step 3. base64url encode the buffer to get the hash\r\n  var hashComputed = base64url(buffer);\r\n\r\n  return (hashProvided === hashComputed);\r\n};\r\n\r\n// This function is used for handling the tuples containing nonce/state/policy/timeStamp in session\r\n// remove the additional tuples from array starting from the oldest ones\r\n// remove expired tuples in array\r\nexports.processArray = function(array, maxAmount, maxAge) {\r\n  // remove the additional tuples, start from the oldest ones\r\n  if (array.length > maxAmount)\r\n    array.splice(0, array.length - maxAmount);\r\n\r\n  // count the number of those already expired\r\n  var count = 0;\r\n  for (var i = 0; i < array.length; i++) {\r\n    var tuple = array[i];\r\n    if (tuple.timeStamp + maxAge * 1000 <= Date.now())\r\n      count++;\r\n    else\r\n      break;\r\n  }\r\n\r\n  // remove the expired ones\r\n  if (count > 0)\r\n    array.splice(0, count);\r\n};\r\n\r\n// This function is used to find the tuple matching the given state, remove the tuple\r\n// from the array and return the tuple\r\n// @array        - array of {state: x, nonce: x, policy: x, timeStamp: x} tuples\r\n// @state        - the tuple which matches the given state\r\nexports.findAndDeleteTupleByState = (array, state) => {\r\n  if (!array)\r\n    return null;\r\n\r\n  for (var i = 0; i < array.length; i++) {\r\n    var tuple = array[i];\r\n    if (tuple['state'] === state) {\r\n      // remove the tuple from the array\r\n      array.splice(i, 1);\r\n      return tuple;\r\n    }\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n// copy the fields from source to dest\r\nexports.copyObjectFields = (source, dest, fields) => {\r\n  if (!source || !dest || !fields || !Array.isArray(fields))\r\n    return;\r\n\r\n  for (var i = 0; i < fields.length; i++)\r\n    dest[fields[i]] = source[fields[i]];\r\n};\r\n\r\nexports.getErrorMessage = (err) => {\r\n  if (typeof err === 'string')\r\n    return err;\r\n  if (err instanceof Error)\r\n    return err.message;\r\n\r\n  // if not string or Error, we try to stringify it\r\n  var str;\r\n  try {\r\n    str = JSON.stringify(err);\r\n  } catch (ex) {\r\n    return err;\r\n  }\r\n  return str;\r\n};\r\n\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/constants.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the 'Software'), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n'use strict';\r\n\r\n// constants that are not strategy specific\r\n\r\nvar CONSTANTS = {};\r\n\r\nCONSTANTS.POLICY_REGEX = /^b2c_1_[0-9a-z._-]+$/i;    // policy is case insensitive\r\nCONSTANTS.TENANTNAME_REGEX = /^[0-9a-zA-Z]+.onmicrosoft.com$/;\r\nCONSTANTS.TENANTID_REGEX = /^[0-9a-zA-Z-]+$/;\r\n\r\nCONSTANTS.CLOCK_SKEW = 300; // 5 minutes\r\n\r\nCONSTANTS.CLIENT_ASSERTION_JWT_LIFETIME = 600; // 10 minutes\r\nCONSTANTS.CLIENT_ASSERTION_TYPE = 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer';\r\n\r\nmodule.exports = CONSTANTS;\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/jsonWebToken.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the 'Software'), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n'use restrict';\r\n\r\nconst aadutils = require('./aadutils');\r\nconst CONSTANTS = require('./constants');\r\nconst jws = require('jws');\r\n\r\n// check if two arrays have common elements\r\nvar hasCommonElem = (array1, array2) => {\r\n  for (var i = 0; i < array1.length; i++) {\r\n    if (array2.indexOf(array1[i]) !== -1)\r\n      return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/* Verify the token and return the payload\r\n *\r\n * @jwtString\r\n * @PEMKey\r\n * @options\r\n *   - algorithms (required)\r\n *   - audience (required)\r\n *   - allowMultiAudiencesInToken (optional, default is true)\r\n *   - validateIssuer (optional, default is true)\r\n *   - issuer (required if validateIssuer is true)\r\n *   - subject (optional, validate if provided)\r\n *   - ignoreExpiration (optional, if not set true we will validate expiration)\r\n * @callback\r\n */\r\nexports.verify = function(jwtString, PEMKey, options, callback) {\r\n\r\n  /*********************************************************************\r\n   * Checking parameters\r\n   ********************************************************************/\r\n\r\n  // check the existence of callback function and options, if we don't have them, that means we have\r\n  // less than 4 parameters passed. This is a server (code) error, we should throw.\r\n  if (!callback)\r\n    throw new Error('callback must be provided in jsonWebToken.verify');\r\n  if (typeof callback !== 'function')\r\n    throw new Error('callback in jsonWebToken.verify must be a function');\r\n  if (!options)\r\n    throw new Error('options must be provided in jsonWebToken.verify');\r\n\r\n  // check jwtString and PEMKey are provided. Since jwtString and PEMKey are generated, this is\r\n  // a non-server error, we shouldn't throw, we just give the error back and let authentication fail.\r\n  if (!jwtString || jwtString === '')\r\n    return done(new Error('jwtString must be provided in jsonWebToken.verify'));\r\n  if (!PEMKey || PEMKey === '')\r\n    return done(new Error('PEMKey must be provided in jsonWebToken.verify'));\r\n\r\n  // asynchronous wrapper for callback\r\n  var done = function() {\r\n    var args = Array.prototype.slice.call(arguments, 0);\r\n    return process.nextTick(function() {\r\n      callback.apply(null, args);\r\n    });\r\n  };\r\n\r\n  // make sure we have the required fields in options\r\n  if (!(options.audience && (typeof options.audience === 'string' || \r\n    (Array.isArray(options.audience) && options.audience.length > 0))))\r\n    return done(new Error('invalid options.audience value is provided in jsonWebToken.verify'));\r\n  if (!options.algorithms)\r\n    return done(new Error('options.algorithms is missing in jsonWebToken.verify'));\r\n  if (!Array.isArray(options.algorithms) || options.algorithms.length == 0 ||\r\n    (options.algorithms.length === 1 && options.algorithms[0] === 'none'))\r\n    return done(new Error('options.algorithms must be an array containing at least one algorithm'));\r\n\r\n  /*********************************************************************\r\n   * Checking jwtString structure, getting header, payload and signature\r\n   ********************************************************************/\r\n\r\n  // split jwtString, make sure we have three parts and we have signature\r\n  var parts = jwtString.split('.');\r\n  if (parts.length !== 3)\r\n    return done(new Error('jwtString is malformed'));\r\n  if (parts[2] === '')\r\n    return done(new Error('signature is missing in jwtString'));\r\n  \r\n  // decode jwsString\r\n  var decodedToken;\r\n  try {\r\n    decodedToken = jws.decode(jwtString);\r\n  } catch(err) {\r\n    return done(new Error('failed to decode the token'));\r\n  }\r\n\r\n  if (!decodedToken) {\r\n    return done(new Error('invalid token'));\r\n  }\r\n\r\n  // get header, payload and signature\r\n  var header = decodedToken.header;\r\n  var payload = decodedToken.payload;\r\n  var signature = decodedToken.signature;\r\n\r\n  if (!header)\r\n    return done(new Error('missing header in the token'));\r\n  if (!payload)\r\n    return done(new Error('missing payload in the token'));\r\n  if (!signature)\r\n    return done(new Error('missing signature in the token'));\r\n\r\n  /*********************************************************************\r\n   * validate algorithm and signature\r\n   ********************************************************************/\r\n\r\n  // header.alg should be one of the algorithms provided in options.algorithms\r\n  if (typeof header.alg !== 'string' || header.alg === '' || header.alg === 'none' ||\r\n    options.algorithms.indexOf(header.alg) == -1) {\r\n    return done(new Error('invalid algorithm'));\r\n  }\r\n\r\n  try {\r\n    var valid = jws.verify(jwtString, header.alg, PEMKey);\r\n    if (!valid)\r\n      return done(new Error('invalid signature'));\r\n  } catch (e) {\r\n    return done(e);\r\n  }\r\n\r\n  /*********************************************************************\r\n   * validate payload content\r\n   ********************************************************************/\r\n\r\n  // (1) issuer\r\n  //   - check the existence and the format of payload.iss\r\n  //   - validate if options.issuer is set\r\n  if (typeof payload.iss !== 'string' || payload.iss === '')\r\n    return done(new Error('invalid iss value in payload'));\r\n  if (options.validateIssuer !== false) {\r\n    if (!options.issuer || options.issuer === '' || (Array.isArray(options.issuer) && options.issuer.length === 0))\r\n      return done(new Error('options.issuer is missing'));\r\n    var valid = false;\r\n    if (Array.isArray(options.issuer))\r\n      valid = (options.issuer.indexOf(payload.iss) !== -1);\r\n    else\r\n      valid = (options.issuer === payload.iss);\r\n    if (!valid)\r\n      return done(new Error('jwt issuer is invalid. expected: ' + options.issuer));\r\n  }\r\n\r\n  // (2) subject\r\n  //   - check the existence and the format of payload.sub\r\n  //   - validate if options.subject is set\r\n  if (typeof payload.sub !== 'string' || payload.sub === '')\r\n    return done(new Error('invalid sub value in payload'));\r\n  if (options.subject && options.subject !== payload.sub)\r\n      return done(new Error('jwt subject is invalid. expected: ' + options.subject));\r\n\r\n  // (3) audience\r\n  //   - always validate\r\n  //   - allow payload.aud to be an array of audience\r\n  //   - options.audience must be a string\r\n  //   - if there are multiple audiences, then azp claim must exist and must equal client_id\r\n  if (typeof options.audience === 'string')\r\n    options.audience = [options.audience, 'spn:' + options.audience];\r\n  if (options.allowMultiAudiencesInToken === false && Array.isArray(payload.aud) && payload.aud.length > 1)\r\n    return done(new Error('mulitple audience in token is not allowed'));\r\n  var payload_audience = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\r\n  if (!hasCommonElem(options.audience, payload_audience))\r\n    return done(new Error('jwt audience is invalid. expected: ' + options.audience));\r\n  if (payload_audience.length > 1) {\r\n    if (typeof payload.azp !== 'string' || payload.azp !== options.clientID)\r\n      return done(new Error('jwt azp is invalid, expected: ' + options.clientID));\r\n  }\r\n\r\n\r\n  // (4) expiration\r\n  //   - check the existence and the format of payload.exp\r\n  //   - validate unless options.ignoreExpiration is set true\r\n  if (typeof payload.exp !== 'number')\r\n    return done(new Error('invalid exp value in payload'));\r\n  if (!options.ignoreExpiration) {\r\n    if (Math.floor(Date.now() / 1000) >= payload.exp + options.clockSkew) {\r\n      return done(new Error('jwt is expired'));\r\n    }\r\n  }\r\n\r\n  // (5) nbf\r\n  //   - check if it exists\r\n  if (payload.nbf) {\r\n    if (typeof payload.nbf !== 'number')\r\n      return done(new Error('nbf value in payload is not a number'));\r\n    if (payload.nbf >= payload.exp)\r\n      return done(new Error('nbf value in payload is not before the exp value'));\r\n    if (payload.nbf >= Math.floor(Date.now() / 1000) + options.clockSkew)\r\n      return done(new Error('jwt is not active'));\r\n  }\r\n\r\n  /*********************************************************************\r\n   * return the payload content\r\n   ********************************************************************/\r\n\r\n  return done(null, payload);\r\n};\r\n\r\n/* Generate client assertion\r\n *\r\n * @params {String} clientID\r\n * @params {String} token_endpoint\r\n * @params {String} privatePEMKey\r\n * @params {String} thumbprint\r\n * @params {Function} callback\r\n */\r\nexports.generateClientAssertion = function(clientID, token_endpoint, privatePEMKey, thumbprint, callback) { \r\n  var header = { 'x5t': thumbprint, 'alg': 'RS256', 'typ': 'JWT' };\r\n  var payload = {\r\n    sub: clientID,\r\n    iss: clientID,\r\n    jti: Date.now() + aadutils.uid(16),\r\n    nbf: Math.floor(Date.now()/1000),\r\n    exp: Math.floor(Date.now()/1000) + CONSTANTS.CLIENT_ASSERTION_JWT_LIFETIME,\r\n    aud: token_endpoint,\r\n  };\r\n\r\n  var clientAssertion;\r\n  var exception = null;\r\n\r\n  try {\r\n    clientAssertion = jws.sign({\r\n      header: header, \r\n      payload: payload, \r\n      privateKey: privatePEMKey\r\n    }); \r\n  } catch (ex) {\r\n    exception = ex;\r\n  }\r\n\r\n  callback(exception, clientAssertion); \r\n};\r\n\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/metadata.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the 'Software'), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n'use strict';\r\n\r\nconst request = require('request');\r\nconst async = require('async');\r\nconst aadutils = require('./aadutils');\r\n\r\nconst Log = require('./logging').getLogger;\r\n\r\nconst log = new Log('AzureAD: Metadata Parser');\r\n\r\nfunction Metadata(url, authtype, options) {\r\n  if (!url) {\r\n    throw new Error('Metadata: url is a required argument');\r\n  }\r\n  if (!authtype || authtype !== 'oidc') {\r\n    throw new Error(`Invalid authtype. authtype must be 'oidc'`);\r\n  }\r\n\r\n  // if logging level specified, switch to it.\r\n  if (options.loggingLevel) { log.levels('console', options.loggingLevel); }\r\n\r\n  this.url = url;\r\n  this.metadata = null;\r\n  this.authtype = authtype;\r\n}\r\n\r\nObject.defineProperty(Metadata, 'url', {\r\n  get: function getUrl() {\r\n    return this.url;\r\n  },\r\n});\r\n\r\nObject.defineProperty(Metadata, 'oidc', {\r\n  get: function getOidc() {\r\n    return this.oidc;\r\n  },\r\n});\r\n\r\nObject.defineProperty(Metadata, 'metadata', {\r\n  get: function getMetadata() {\r\n    return this.metadata;\r\n  },\r\n});\r\n\r\nMetadata.prototype.updateOidcMetadata = function updateOidcMetadata(doc, next) {\r\n  log.info('Request to update the Open ID Connect Metadata');\r\n\r\n  const self = this;\r\n\r\n  var oidc = {};\r\n  oidc.algorithms = doc.id_token_signing_alg_values_supported;\r\n  oidc.authorization_endpoint = doc.authorization_endpoint;\r\n  oidc.end_session_endpoint = doc.end_session_endpoint;\r\n  oidc.issuer = doc.issuer;\r\n  oidc.token_endpoint = doc.token_endpoint;\r\n  oidc.userinfo_endpoint = doc.userinfo_endpoint;\r\n  self.oidc = oidc;\r\n\r\n  const jwksUri = doc.jwks_uri;\r\n\r\n  log.info('Algorithm retrieved was: ', self.oidc.algorithms);\r\n  log.info('Issuer we are using is: ', self.oidc.issuer);\r\n  log.info('Key Endpoint we will use is: ', jwksUri);\r\n  log.info('Authentication endpoint we will use is: ', self.oidc.authorization_endpoint);\r\n  log.info('Token endpoint we will use is: ', self.oidc.token_endpoint);\r\n  log.info('User info endpoint we will use is: ', self.oidc.userinfo_endpoint);\r\n  log.info('The logout endpoint we will use is: ', self.oidc.end_session_endpoint);\r\n\r\n  // fetch the signing keys\r\n  request.get(jwksUri, { json: true }, (err, response, body) => {\r\n    if (err) {\r\n      return next(err);\r\n    }\r\n    if (response.statusCode !== 200) {\r\n      return next(new Error(`Error: ${response.statusCode} Cannot get AAD Signing Keys`));\r\n    }\r\n    self.oidc.keys = body.keys;\r\n    return next();\r\n  });\r\n};\r\n\r\nMetadata.prototype.generateOidcPEM = function generateOidcPEM(kid) {\r\n  const keys = this && this.oidc && Array.isArray(this.oidc.keys) ? this.oidc.keys : null;\r\n  let pubKey = null;\r\n  let foundKey = false;\r\n\r\n  if (!kid) {\r\n    throw new Error('kid is missing');\r\n  }\r\n\r\n  if (!keys) {\r\n    throw new Error('keys is missing');\r\n  }\r\n\r\n  keys.some((key) => {\r\n    log.info('working on key:', key);\r\n\r\n    // are we working on the right key?\r\n    if (key.kid !== kid) {\r\n      return false;\r\n    }\r\n\r\n    // check for `modulus` to be present\r\n    if (!key.n) {\r\n      log.warn('modulus is empty; corrupt key', key);\r\n      return false;\r\n    }\r\n\r\n    // check for `exponent` to be present\r\n    if (!key.e) {\r\n      log.warn('exponent is empty; corrupt key', key);\r\n      return false;\r\n    }\r\n\r\n    // generate PEM from `modulus` and `exponent`\r\n    pubKey = aadutils.rsaPublicKeyPem(key.n, key.e);\r\n    foundKey = true;\r\n    \r\n    return pubKey;\r\n  });\r\n\r\n  if (!foundKey)\r\n    throw new Error(`a key with kid %s cannot be found`, kid);\r\n\r\n  if (!pubKey)\r\n    throw new Error(`generating public key pem failed for kid: %s`, kid);\r\n\r\n  return pubKey;\r\n};\r\n\r\nMetadata.prototype.fetch = function fetch(callback) {\r\n  const self = this;\r\n\r\n  async.waterfall([\r\n    // fetch the Federation metadata for the AAD tenant\r\n    (next) => {\r\n      request.get(self.url, (err, response, body) => {\r\n        if (err) {\r\n          return next(err);\r\n        }\r\n        if (response.statusCode !== 200) {\r\n          log.error('Cannot get AAD Federation metadata from endpoint you specified', self.url);\r\n          return next(new Error(`Error: ${response.statusCode} Cannot get AAD Federation metadata\r\n            from ${self.url}`));\r\n        }\r\n        return next(null, body);\r\n      });\r\n    },\r\n    // parse retrieved metadata\r\n    (body, next) => {\r\n      // use json parser for oidc authType\r\n      log.info('Parsing JSON retreived from the endpoint');\r\n      self.metadata = JSON.parse(body);\r\n      return next(null);\r\n    },\r\n    // call update method for parsed metadata and authType\r\n    (next) => {\r\n      return self.updateOidcMetadata(self.metadata, next);\r\n    },\r\n  ], (waterfallError) => {\r\n    // return err or success (err === null) to callback\r\n    callback(waterfallError);\r\n  });\r\n};\r\n\r\nexports.Metadata = Metadata;\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/logging.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the 'Software'), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n'use strict';\r\n\r\nconst bunyan = require('bunyan');\r\n\r\nfunction getLogger(name) {\r\n  const log = bunyan.createLogger({\r\n    name,\r\n    streams: [{\r\n      stream: process.stderr,\r\n      level: 'error',\r\n      name: 'error',\r\n    }, {\r\n      stream: process.stdout,\r\n      level: 'warn',\r\n      name: 'console',\r\n    }],\r\n  });\r\n  return log;\r\n}\r\n\r\nexports.getLogger = getLogger;\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/oidcstrategy.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the 'Software'), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n'use strict';\r\n\r\n/* eslint no-underscore-dangle: 0 */\r\n\r\n// third party packages\r\nconst async = require('async');\r\nconst base64url = require('base64url');\r\nconst cacheManager = require('cache-manager');\r\nconst _ = require('lodash');\r\nconst jws = require('jws');\r\nconst passport = require('passport');\r\nconst querystring = require('querystring');\r\nconst url = require('url');\r\nconst urlValidator = require('valid-url');\r\nconst util = require('util');\r\n\r\n// packages from this library\r\nconst aadutils = require('./aadutils');\r\nconst CONSTANTS = require('./constants');\r\nconst jwt = require('./jsonWebToken');\r\nconst jwe = require('./jwe');\r\n\r\n// For the following packages we get a constructor and we will use 'new' to create an instance\r\nconst InternalOAuthError = require('./errors/internaloautherror');\r\nconst InternalOpenIDError = require('./errors/internalopeniderror');\r\nconst Log = require('./logging').getLogger;\r\nconst Metadata = require('./metadata').Metadata;\r\nconst OAuth2 = require('oauth').OAuth2;\r\nconst SessionContentHandler = require('./sessionContentHandler').SessionContentHandler;\r\nconst CookieContentHandler = require('./cookieContentHandler').CookieContentHandler;\r\nconst Validator = require('./validator').Validator;\r\n\r\n// global variable definitions\r\nconst log = new Log('AzureAD: OIDC Passport Strategy');\r\n\r\nconst memoryCache = cacheManager.caching({ store: 'memory', max: 3600, ttl: 1800 /* seconds */ });\r\nconst ttl = 1800; // 30 minutes cache\r\n// Note: callback is optional in set() and del().\r\n\r\n// For each microsoft login page, we generate a tuple containing nonce/state/etc, and save it in session.\r\n// 1. NONCE_LIFE_TIME is the default life time of the tuple. The default value is 3600 seconds. The life\r\n//    time is configurable by user.\r\n// 2. NONCE_MAX_AMOUNT is the max amount of tuples a user's session can have. We limit it to 10.\r\n//    This value limits the amount of microsoft login page tabs a user can open before the user types\r\n//    username and password to 10. If the user opens more than 10 login tabs, we only honor the most \r\n//    recent 10 tabs within the life time.\r\nconst NONCE_MAX_AMOUNT = 10;\r\nconst NONCE_LIFE_TIME = 3600; // second\r\n\r\nfunction makeProfileObject(src, raw) {\r\n  return {\r\n    sub: src.sub,\r\n    oid: src.oid,\r\n    upn: src.upn,\r\n    displayName: src.name,\r\n    name: {\r\n      familyName: src.family_name,\r\n      givenName: src.given_name,\r\n      middleName: src.middle_name,\r\n    },\r\n    emails: src.emails,\r\n    _raw: raw,\r\n    _json: src,\r\n  };\r\n}\r\n\r\nfunction onProfileLoaded(strategy, args) {\r\n  function verified(err, user, info) {\r\n    if (err) {\r\n      return strategy.error(err);\r\n    }\r\n    if (!user) {\r\n      return strategy.failWithLog(info);\r\n    }\r\n    return strategy.success(user, info);\r\n  }\r\n\r\n  const verifyArityArgsMap = {\r\n    8: 'iss sub profile jwtClaims access_token refresh_token params',\r\n    7: 'iss sub profile access_token refresh_token params',\r\n    6: 'iss sub profile access_token refresh_token',\r\n    4: 'iss sub profile',\r\n    3: 'iss sub',\r\n  };\r\n\r\n  const arity = (strategy._passReqToCallback) ? strategy._verify.length - 1 : strategy._verify.length;\r\n  let verifyArgs = [args.profile, verified];\r\n\r\n  if (verifyArityArgsMap[arity]) {\r\n    verifyArgs = verifyArityArgsMap[arity]\r\n      .split(' ')\r\n      .map((argName) => {\r\n        return args[argName];\r\n      })\r\n      .concat([verified]);\r\n  }\r\n\r\n  if (strategy._passReqToCallback) {\r\n    verifyArgs.unshift(args.req);\r\n  }\r\n\r\n  return strategy._verify.apply(strategy, verifyArgs);\r\n}\r\n\r\n/**\r\n * Applications must supply a `verify` callback, for which the function\r\n * signature is:\r\n *\r\n *     function(token, done) { ... }\r\n * or\r\n *     function(req, token, done) { .... }  \r\n *  \r\n * (passReqToCallback must be set true in options in order to use the second signature.)\r\n *\r\n * `token` is the verified and decoded bearer token provided as a credential.\r\n * The verify callback is responsible for finding the user who posesses the\r\n * token, and invoking `done` with the following arguments:\r\n *\r\n *     done(err, user, info);\r\n *\r\n * If the token is not valid, `user` should be set to `false` to indicate an\r\n * authentication failure.  Additional token `info` can optionally be passed as\r\n * a third argument, which will be set by Passport at `req.authInfo`, where it\r\n * can be used by later middleware for access control.  This is typically used\r\n * to pass any scope associated with the token.\r\n *\r\n * Options:\r\n *\r\n *   - `identityMetadata`   (1) Required\r\n *                          (2) must be a https url string\r\n *                          (3) Description:\r\n *                          the metadata endpoint provided by the Microsoft Identity Portal that provides \r\n *                          the keys and other important info at runtime. Examples:\r\n *                          <1> v1 tenant-specific endpoint\r\n *                          - https://login.microsoftonline.com/your_tenant_name.onmicrosoft.com/.well-known/openid-configuration\r\n *                          - https://login.microsoftonline.com/your_tenant_guid/.well-known/openid-configuration\r\n *                          <2> v1 common endpoint\r\n *                          - https://login.microsoftonline.com/common/.well-known/openid-configuration\r\n *                          <3> v2 tenant-specific endpoint\r\n *                          - https://login.microsoftonline.com/your_tenant_name.onmicrosoft.com/v2.0/.well-known/openid-configuration\r\n *                          - https://login.microsoftonline.com/your_tenant_guid/v2.0/.well-known/openid-configuration\r\n *                          <4> v2 common endpoint\r\n *                          - https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration\r\n *\r\n *   - `clientID`           (1) Required\r\n *                          (2) must be a string\r\n *                          (3) Description:\r\n *                          The Client ID of your app in AAD\r\n *\r\n *   - `responseType`       (1) Required\r\n *                          (2) must be 'code', 'code id_token', 'id_token code' or 'id_token'\r\n *                          (3) Description:\r\n *                          For login only flows use 'id_token'. For accessing resources use `code id_token`, 'id_token code' or `code`\r\n *\r\n *   - `responseMode`       (1) Required\r\n *                          (2) must be 'query' or 'form_post'\r\n *                          (3) Description:\r\n *                          How you get the authorization code and tokens back\r\n *\r\n *   - `redirectUrl`        (1) Required\r\n *                          (2) must be a https url string, unless you set `allowHttpForRedirectUrl` to true\r\n *                          (3) Description:\r\n *                          The reply URL registered in AAD for your app\r\n *\r\n *   - `allowHttpForRedirectUrl`\r\n *                          (1) Required to set to true if you want to use http url for redirectUrl\r\n *                          (2) Description:\r\n *                          The default value is false. It's OK to use http like 'http://localhost:3000' in the\r\n *                          dev environment, but in production environment https should always be used. \r\n *\r\n *   - `clientSecret`       (1) This option only applies when `responseType` is 'code', 'id_token code' or 'code id_token'.\r\n *                              To redeem an authorization code, we can use either client secret flow or client assertion flow.\r\n *                              (1.1) For B2C, clientSecret is required since client assertion is not supported\r\n *                              (1.2) For non-B2C, both flows are supported. Developer must provide either clientSecret, or \r\n *                                    thumbprint and privatePEMKey. We use clientSecret if it is provided, otherwise we use \r\n *                                    thumbprint and privatePEMKey for the client assertion flow.\r\n *                          (2) must be a string\r\n *                          (3) Description:\r\n *                          The app key of your app from AAD. \r\n *                          NOTE: For B2C, the app key sometimes contains '\\', please replace '\\' with '\\\\' in the app key, otherwise\r\n *                          '\\' will be treated as the beginning of a escaping character\r\n *\r\n *   - `thumbprint`         (1) Required if you want to use client assertion to redeem an authorization code (non-B2C only)\r\n *                          (2) must be a base64url encoded string\r\n *                          (3) Description:\r\n *                          The thumbprint (hash value) of the public key\r\n *\r\n *   - `privatePEMKey`      (1) Required if you want to use client assertion to redeem an authorization code (non-B2C only)\r\n *                          (2) must be a pem key\r\n *                          (3) Description:\r\n *                          The private key used to sign the client assertion JWT\r\n *\r\n *   - `isB2C`              (1) Required for B2C\r\n *                          (2) must be true for B2C, default is false\r\n *                          (3) Description:\r\n *                          set to true if you are using B2C, default is false\r\n *\r\n *   - `validateIssuer`     (1) Required to set to false if you don't want to validate issuer, default is true\r\n *                          (2) Description:\r\n *                          For common endpoint, you should either set `validateIssuer` to false, or provide the `issuer`, since\r\n *                          we cannot grab the `issuer` value from metadata.\r\n *                          For non-common endpoint, we use the `issuer` from metadata, and `validateIssuer` should be always true\r\n *\r\n *   - `issuer`             (1) Required if you are using common endpoint and set `validateIssuer` to true, or if you want to specify the allowed issuers\r\n *                          (2) must be a string or an array of strings\r\n *                          (3) Description:\r\n *                          For common endpoint, we use the `issuer` provided.\r\n *                          For non-common endpoint, if the `issuer` is not provided, we use the issuer provided by metadata\r\n *\r\n *   - `passReqToCallback`  (1) Required to set true if you want to use the `function(req, token, done)` signature for the verify function, default is false\r\n *                          (2) Description:\r\n *                          Set `passReqToCallback` to true use the `function(req, token, done)` signature for the verify function\r\n *                          Set `passReqToCallback` to false use the `function(token, done)` signature for the verify function \r\n *\r\n *   - `useCookieInsteadOfSession`\r\n *                          (1) Required to set true if you don't want to use session. Default value is false.\r\n *                          (2) Description:\r\n *                          Passport-azure-ad needs to save state and nonce somewhere for validation purpose. If this option is set true, it will encrypt \r\n *                          state and nonce and put them into cookie. If this option is false, we save state and nonce in session.\r\n *\r\n *   - `cookieEncryptionKeys`\r\n *                          (1) Required if `useCookieInsteadOfSession` is true.\r\n *                          (2) Description:\r\n *                          This must be an array of key items. Each key item has the form { key: '...', iv: '...' }, where key is any string of length 32,\r\n *                          and iv is any string of length 12. \r\n *                          We always use the first key item with AES-256-GCM algorithm to encrypt cookie, but we will try every key item when we decrypt\r\n *                          cookie. This helps when you want to do key roll over.\r\n *\r\n *   - `scope`              (1) Optional\r\n *                          (2) must be a string or an array of strings\r\n *                          (3) Description:\r\n *                          list of scope values indicating the required scope of the access token for accessing the requested\r\n *                          resource. Ex: ['email', 'profile']. \r\n *                          We send 'openid' by default. For B2C, we also send 'offline_access' (to get refresh_token) and\r\n *                          clientID (to get access_token) by default.\r\n *\r\n *   - `loggingLevel`       (1) Optional\r\n *                          (2) must be 'info', 'warn', 'error'\r\n *                          (3) Description:  \r\n *                          logging level  \r\n *\r\n *   - `nonceLifetime`      (1) Optional\r\n *                          (2) must be a positive integer\r\n *                          (3) Description:\r\n *                          the lifetime of nonce in session or cookie, default value is NONCE_LIFE_TIME\r\n *\r\n *   - `nonceMaxAmount`     (1) Optional\r\n *                          (2) must be a positive integer\r\n *                          (3) Description:\r\n *                          the max amount of nonce in session or cookie, default value is NONCE_MAX_AMOUNT\r\n *\r\n *   - `clockSkew`          (1) Optional\r\n *                          (2) must be a positive integer\r\n *                          (3) Description:\r\n *                          the clock skew (in seconds) allowed in token validation, default value is CLOCK_SKEW\r\n *\r\n * Examples:\r\n *\r\n * passport.use(new OIDCStrategy({\r\n *     identityMetadata: config.creds.identityMetadata,\r\n *     clientID: config.creds.clientID,\r\n *     responseType: config.creds.responseType,\r\n *     responseMode: config.creds.responseMode\r\n *     redirectUrl: config.creds.redirectUrl, \r\n *     allowHttpForRedirectUrl: config.creds.allowHttpForRedirectUrl,\r\n *     clientSecret: config.creds.clientSecret,\r\n *     thumbprint: config.creds.thumbprint,\r\n *     privatePEMKey: config.crecs.privatePEMKey,\r\n *     isB2C: config.creds.isB2C,\r\n *     validateIssuer: config.creds.validateIssuer,\r\n *     issuer: config.creds.issuer,\r\n *     scope: config.creds.scopes,\r\n *     passReqToCallback: config.creds.passReqToCallback,\r\n *     loggingLevel: config.creds.loggingLevel,\r\n *     nonceLifetime: config.creds.nonceLifetime,\r\n *     useCookieInsteadOfSession: config.creds.useCookieInsteadOfSession,\r\n *     cookieEncryptionKeys: config.creds.cookieEncryptionKeys\r\n *   },\r\n *   function(token, done) {\r\n *     User.findById(token.sub, function (err, user) {\r\n *       if (err) { return done(err); }\r\n *       if (!user) { return done(null, false); }\r\n *       return done(null, user, token);\r\n *     });\r\n *   }\r\n * ));\r\n *\r\n * For further details on HTTP Bearer authentication, refer to [The OAuth 2.0 Authorization Protocol: Bearer Tokens](http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer)\r\n * For further details on JSON Web Token, refert to [JSON Web Token](http://tools.ietf.org/html/draft-ietf-oauth-json-web-token)\r\n *\r\n * @param {object} options - The Options.\r\n * @param {Function} verify - The verify callback.\r\n * @constructor\r\n */\r\nfunction Strategy(options, verify) {\r\n  passport.Strategy.call(this);\r\n\r\n  /*\r\n   *  Caution when you want to change these values in the member functions of\r\n   *  Strategy, don't use `this`, since `this` points to a subclass of `Strategy`.\r\n   *  To get `Strategy`, use Object.getPrototypeOf(this).\r\n   *  \r\n   *  More comments at the beginning of `Strategy.prototype.authenticate`. \r\n   */\r\n  this._options = options;\r\n  this.name = 'azuread-openidconnect';\r\n\r\n  // stuff related to the verify function\r\n  this._verify = verify;\r\n  this._passReqToCallback = !!options.passReqToCallback;\r\n\r\n  if (options.useCookieInsteadOfSession === true)\r\n    this._useCookieInsteadOfSession = true;\r\n  else\r\n    this._useCookieInsteadOfSession = false;\r\n\r\n  if (!this._useCookieInsteadOfSession) {\r\n    // For each microsoft login page tab, we generate a {state, nonce, policy, timeStamp} tuple,\r\n    // normally user won't keep opening microsoft login page in new tabs without putting their \r\n    // password for more than 10 tabs, so we only keep the most recent 10 tuples in session.\r\n    // The lifetime of each tuple is 60 minutes or user specified.\r\n    this._sessionContentHandler = new SessionContentHandler(options.nonceMaxAmount || NONCE_MAX_AMOUNT, options.nonceLifetime || NONCE_LIFE_TIME);\r\n  } else {\r\n    this._cookieContentHandler = new CookieContentHandler(options.nonceMaxAmount || NONCE_MAX_AMOUNT, options.nonceLifetime || NONCE_LIFE_TIME, options.cookieEncryptionKeys);\r\n  }\r\n\r\n  /* When a user is authenticated for the first time, passport adds a new field\r\n   * to req.session called 'passport', and puts a 'user' property inside (or your\r\n   * choice of field name and property name if you change passport._key and \r\n   * passport._userProperty values). req.session['passport']['user'] is usually \r\n   * user_id (or something similar) of the authenticated user to reduce the size\r\n   * of session. When the user logs out, req.session['passport']['user'] will be\r\n   * destroyed. Any request between login (when authenticated for the first time)\r\n   * and logout will have the 'user_id' in req.session['passport']['user'], so\r\n   * passport can fetch it, find the user object in database and put the user\r\n   * object into a new field: req.user. Then the subsequent middlewares and the \r\n   * app can use the user object. This is how passport keeps user authenticated. \r\n   *\r\n   * For state validation, we also take advantage of req.session. we create a new\r\n   * field: req.session[sessionKey], where the sessionKey is our choice (in fact, \r\n   * this._key, see below). When we send a request with state, we put state into\r\n   * req.session[sessionKey].state; when we expect a request with state in query\r\n   * or body, we compare the state in query/body with the one stored in \r\n   * req.session[sessionKey].state, and then destroy req.session[sessionKey].state.\r\n   * User can provide a state by using `authenticate(Strategy, {state: 'xxx'})`, or\r\n   * one will be generated automatically. This is essentially how passport-oauth2\r\n   * library does the state validation, and we use the same way in our library. \r\n   *\r\n   * request structure will look like the following. In real request some fields\r\n   * might not be there depending on the purpose of the request.\r\n   *\r\n   *    request ---|--- sessionID\r\n   *               |--- session --- |--- ...\r\n   *               |                |--- 'passport' ---| --- 'user': 'user_id etc'\r\n   *               |                |---  sessionKey---| --- state: 'xxx'            \r\n   *               |--- ...\r\n   *               |--- 'user':  full user info\r\n   */\r\n  this._key = options.sessionKey || ('OIDC: ' + options.redirectUrl);\r\n\r\n  if (!options.identityMetadata) {\r\n    // default value should be https://login.microsoftonline.com/common/.well-known/openid-configuration\r\n    log.error('OIDCStrategy requires a metadata location that contains cert data for RSA and ECDSA callback.');\r\n    throw new TypeError(`OIDCStrategy requires a metadata location that contains cert data for RSA and ECDSA callback.`);\r\n  }\r\n\r\n  // if logging level specified, switch to it.\r\n  if (options.loggingLevel) { log.levels('console', options.loggingLevel); }\r\n  this.log = log;\r\n\r\n  // clock skew. Must be a postive integer\r\n  if (options.clockSkew && (typeof options.clockSkew !== 'number' || options.clockSkew <= 0 || options.clockSkew % 1 !== 0))\r\n    throw new Error('clockSkew must be a positive integer');\r\n  if (!options.clockSkew)\r\n    options.clockSkew = CONSTANTS.CLOCK_SKEW;\r\n\r\n  /****************************************************************************************\r\n   * Take care of identityMetadata\r\n   * (1) Check if it is common endpoint\r\n   * (2) For B2C, one cannot use the common endpoint. tenant name or guid must be specified\r\n   * (3) We add telemetry to identityMetadata automatically\r\n   ***************************************************************************************/\r\n\r\n  // check existence\r\n  if (!options.identityMetadata) {\r\n    log.error('OIDCStrategy requires a metadata location that contains cert data for RSA and ECDSA callback.');\r\n    throw new TypeError(`OIDCStrategy requires a metadata location that contains cert data for RSA and ECDSA callback.`);\r\n  }\r\n\r\n  // check if we are using the common endpoint\r\n  options.isCommonEndpoint = (options.identityMetadata.indexOf('/common/') != -1);\r\n\r\n  // isB2C is false by default  \r\n  if (options.isB2C !== true)\r\n    options.isB2C = false;\r\n\r\n  // add telemetry\r\n  options.identityMetadata = options.identityMetadata.concat(`?${aadutils.getLibraryProductParameterName()}=${aadutils.getLibraryProduct()}`)\r\n  .concat(`&${aadutils.getLibraryVersionParameterName()}=${aadutils.getLibraryVersion()}`);\r\n\r\n  /****************************************************************************************\r\n   * Take care of issuer and audience\r\n   * (1) We use user provided `issuer`, and the issuer value from metadata if the metadata\r\n   *     comes from tenant-specific endpoint (in other words, either the identityMetadata\r\n   *     is tenant-specific, or it is common but you provide tenantIdOrName in \r\n   *     passport.authenticate). \r\n   *\r\n   *     For common endpoint, if `issuer` is not provided by user, and `tenantIdOrName` is \r\n   *     not used in passport.authenticate, then we don't know the issuer, and `validateIssuer`\r\n   *     must be set to false\r\n   * (2) `validateIssuer` is true by default. we validate issuer unless validateIssuer is set false\r\n   * (3) `audience` must be the clientID of this app\r\n   ***************************************************************************************/\r\n  if (options.validateIssuer !== false)\r\n    options.validateIssuer = true;\r\n  if (!options.validateIssuer)\r\n    log.warn(`Production environments should always validate the issuer.`);\r\n\r\n  if (options.issuer === '')\r\n    options.issuer = null;\r\n  // make issuer an array\r\n  if (options.issuer && !Array.isArray(options.issuer))\r\n    options.issuer = [options.issuer];\r\n\r\n  options.audience = options.clientID;\r\n  options.allowMultiAudiencesInToken = false;\r\n\r\n  /****************************************************************************************\r\n   * Take care of scope\r\n   ***************************************************************************************/\r\n   // make scope an array\r\n  if (!options.scope)\r\n    options.scope = [];\r\n  if (!Array.isArray(options.scope))\r\n    options.scope = [options.scope];\r\n  // always have 'openid' scope for openID Connect\r\n  if (options.scope.indexOf('openid') === -1)\r\n    options.scope.push('openid');\r\n  options.scope = options.scope.join(' ');\r\n\r\n  /****************************************************************************************\r\n   * Check if we are using v2 endpoint, v2 doesn't have an userinfo endpoint\r\n   ***************************************************************************************/\r\n  if (options.identityMetadata.indexOf('/v2.0/') != -1)\r\n    options._isV2 = true;\r\n\r\n  /****************************************************************************************\r\n   * validate other necessary option items provided, we validate them here and only once\r\n   ***************************************************************************************/\r\n  // change responseType 'id_token code' to 'code id_token' since the former is not supported by B2C\r\n  if (options.responseType === 'id_token code')\r\n    options.responseType = 'code id_token';\r\n\r\n  var itemsToValidate = {};\r\n  aadutils.copyObjectFields(options, itemsToValidate, ['clientID', 'redirectUrl', 'responseType', 'responseMode', 'identityMetadata']); \r\n\r\n  var validatorConfiguration = {\r\n    clientID: Validator.isNonEmpty,\r\n    responseType: Validator.isTypeLegal,\r\n    responseMode: Validator.isModeLegal,\r\n    identityMetadata: Validator.isHttpsURL\r\n  };\r\n  \r\n  // redirectUrl is https by default\r\n  if (options.allowHttpForRedirectUrl === true)\r\n    validatorConfiguration.redirectUrl = Validator.isURL;\r\n  else\r\n    validatorConfiguration.redirectUrl = Validator.isHttpsURL;\r\n\r\n  // validator will throw exception if a required option is missing\r\n  var validator = new Validator(validatorConfiguration);\r\n  validator.validate(itemsToValidate);\r\n\r\n  // validate client secret, thumbprint and privatePEMKey for hybrid and authorization flow\r\n  if (options.responseType !== 'id_token') {\r\n    if (options.isB2C && !options.clientSecret) {\r\n      // for B2C, clientSecret is required to redeem authorization code.\r\n      throw new Error('clientSecret must be provided for B2C hybrid flow and authorization code flow.');\r\n    } else if (!options.clientSecret) {\r\n      // for non-B2C, we can use either clientSecret or clientAssertion to redeem authorization code.\r\n      // Therefore, we need either clientSecret, or privatePEMKey and thumbprint (so we can create clientAssertion).\r\n      if (!options.privatePEMKey)\r\n        throw new Error('privatePEMKey is not provided. Please provide either clientSecret, or privatePEMKey and thumbprint.');\r\n      if (!options.thumbprint)\r\n        throw new Error('thumbprint is not provided. Please provide either clientSecret, or privatePEMKey and thumbprint.');\r\n    }\r\n  }\r\n\r\n  // we allow 'http' for the redirectUrl, but don't recommend using 'http'\r\n  if (urlValidator.isHttpUri(options.redirectUrl))\r\n    log.warn(`Using http for redirectUrl is not recommended, please consider using https`);\r\n}\r\n\r\n// Inherit from `passport.Strategy`.\r\nutil.inherits(Strategy, passport.Strategy);\r\n\r\n/**\r\n * Authenticate request by delegating to an OpenID Connect provider.\r\n *\r\n * @param {Object} req\r\n * @param {Object} options\r\n * @api protected\r\n */\r\nStrategy.prototype.authenticate = function authenticateStrategy(req, options) {\r\n  /* \r\n   * We should be careful using 'this'. Avoid the usage like `this.xxx = ...`\r\n   * unless you know what you are doing.\r\n   *\r\n   * In the passport source code \r\n   * (https://github.com/jaredhanson/passport/blob/master/lib/middleware/authenticate.js)\r\n   * when it attempts to call the `oidcstrategy.authenticate` function, passport\r\n   * creates an instance inherting oidcstrategy and then calls `instance.authenticate`.  \r\n   * Therefore, when we come here, `this` is the instance, its prototype is the\r\n   * actual oidcstrategy, i.e. the `Strategy`. This means:\r\n   * (1) `this._options = `, `this._verify = `, etc only adds new fields to the\r\n   *      instance, it doesn't change the values in oidcstrategy, i.e. `Strategy`. \r\n   * (2) `this._options`, `this._verify`, etc returns the field in the instance,\r\n   *     and if there is none, returns the field in oidcstrategy, i.e. `strategy`.\r\n   * (3) each time we call `authenticate`, we will get a brand new instance\r\n   * \r\n   * If you want to change the values in `Strategy`, use \r\n   *      const oidcstrategy = Object.getPrototypeOf(self);\r\n   * to get the strategy first.\r\n   *\r\n   * Note: Simply do `const self = Object.getPrototypeOf(this)` and use `self`\r\n   * won't work, since the `this` instance has a couple of functions like\r\n   * success/fail/error... which `authenticate` will call. The following is the\r\n   * structure of `this`:\r\n   *\r\n   *   this\r\n   *   | --  success:  function(user, info)\r\n   *   | --  fail:     function(challenge, status)\r\n   *   | --  redirect: function(url, status)\r\n   *   | --  pass:     function()\r\n   *   | --  __proto__:  Strategy\r\n   *                 | --  _verify\r\n   *                 | --  _options\r\n   *                 | --  ...\r\n   *                 | --  __proto__:\r\n   *                              | --  authenticate:  function(req, options)\r\n   *                              | --  ...\r\n   */ \r\n  const self = this;\r\n\r\n  var resource = options && options.resourceURL;\r\n  var customState = options && options.customState;\r\n  var tenantIdOrName = options && options.tenantIdOrName;\r\n  var login_hint = options && options.login_hint;\r\n  var domain_hint = options && options.domain_hint;\r\n  var prompt = options && options.prompt;\r\n  var extraAuthReqQueryParams = options && options.extraAuthReqQueryParams;\r\n  var extraTokenReqQueryParams = options && options.extraTokenReqQueryParams;\r\n  var response = options && options.response;\r\n\r\n  // validate tenantIdOrName if it is provided\r\n  if (tenantIdOrName && !CONSTANTS.TENANTNAME_REGEX.test(tenantIdOrName) && !CONSTANTS.TENANTID_REGEX.test(tenantIdOrName))\r\n    return self.failWithLog(`In passport.authenticate: invalid tenantIdOrName ${tenantIdOrName}`);\r\n\r\n  // 'params': items we get from the request or metadata, such as id_token, code, policy, metadata, cacheKey, etc\r\n  var params = { 'tenantIdOrName': tenantIdOrName, 'extraAuthReqQueryParams': extraAuthReqQueryParams, 'extraTokenReqQueryParams': extraTokenReqQueryParams }; \r\n  // 'oauthConfig': items needed for oauth flow (like redirection, code redemption), such as token_endpoint, userinfo_endpoint, etc\r\n  var oauthConfig = { 'resource': resource, 'customState': customState, 'domain_hint': domain_hint, 'login_hint': login_hint, 'prompt': prompt, 'response': response };\r\n  // 'optionsToValidate': items we need to validate id_token against, such as issuer, audience, etc  \r\n  var optionsToValidate = {}; \r\n\r\n  async.waterfall(\r\n    [\r\n      /*****************************************************************************\r\n       * Step 1. Collect information from the req and save the info into params\r\n       ****************************************************************************/\r\n      (next) => {\r\n        return self.collectInfoFromReq(params, req, next, response);\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Step 2. Load metadata, use the information from 'params' and 'self._options'\r\n       * to configure 'oauthConfig' and 'optionsToValidate'\r\n       ****************************************************************************/\r\n      (next) => {\r\n        return self.setOptions(params, oauthConfig, optionsToValidate, next);\r\n      },\r\n\r\n      /***************************************************************************** \r\n       * Step 3. Handle the flows\r\n       *----------------------------------------------------------------------------\r\n       * (1) implicit flow (response_type = 'id_token')\r\n       *     This case we get a 'id_token'\r\n       * (2) hybrid flow (response_type = 'id_token code')\r\n       *     This case we get both 'id_token' and 'code'\r\n       * (3) authorization code flow (response_type = 'code')\r\n       *     This case we get a 'code', we will use it to get 'access_token' and 'id_token'\r\n       * (4) for any other request, we will ask for authorization and initialize \r\n       *     the authorization process \r\n       ****************************************************************************/\r\n      (next) => {\r\n        if (params.err) {\r\n          // handle the error\r\n          return self._errorResponseHandler(params.err, params.err_description, next);\r\n        } else if (!params.id_token && !params.code) {\r\n          // ask for authorization, initialize the authorization process\r\n          return self._flowInitializationHandler(oauthConfig, req, next);\r\n        } else if (params.id_token && params.code) {\r\n          // handle hybrid flow\r\n          return self._hybridFlowHandler(params, oauthConfig, optionsToValidate, req, next);\r\n        } else if (params.id_token) {\r\n          // handle implicit flow\r\n          return self._implicitFlowHandler(params, optionsToValidate, req, next);\r\n        } else {\r\n          // handle authorization code flow\r\n          return self._authCodeFlowHandler(params, oauthConfig, optionsToValidate, req, next);\r\n        }\r\n      }\r\n    ],\r\n\r\n    (waterfallError) => {\r\n      // this code gets called after the three steps above are done\r\n      if (waterfallError) {\r\n        return self.failWithLog(`${aadutils.getErrorMessage(waterfallError)}`);\r\n      }\r\n      return true;\r\n    });\r\n};\r\n\r\n/**\r\n * Collect information from the request, for instance, code, err, id_token etc\r\n *\r\n * @param {Object} params \r\n * @param {Object} req    \r\n * @param {Object} next\r\n */\r\nStrategy.prototype.collectInfoFromReq = function(params, req, next, response) {\r\n  const self = this;\r\n\r\n  // the things we will put into 'params':\r\n  // err, err_description, id_token, code, policy, state, nonce, cachekey, metadata\r\n\r\n  // -------------------------------------------------------------------------\r\n  // we shouldn't get any access_token or refresh_token from the request\r\n  // -------------------------------------------------------------------------\r\n  if ((req.query && (req.query.access_token || req.query.refresh_token)) ||\r\n    (req.body && (req.body.access_token || req.body.refresh_token)))\r\n    return next(new Error('In collectInfoFromReq: neither access token nor refresh token is expected in the incoming request'));\r\n\r\n  // -------------------------------------------------------------------------\r\n  // we might get err, id_token, code, state from the request\r\n  // -------------------------------------------------------------------------\r\n  var source = null;\r\n\r\n  if (req.query && (req.query.error || req.query.id_token || req.query.code))\r\n    source = req.query;\r\n  else if (req.body && (req.body.error || req.body.id_token || req.body.code))\r\n    source = req.body;\r\n\r\n  if (source) {\r\n    params.err = source.error;\r\n    params.err_description = source.error_description;\r\n    params.id_token = source.id_token;\r\n    params.code = source.code;\r\n    params.state = source.state;\r\n    if (source.state && source.state.length >= 38) {\r\n      // the random generated state always has 32 characters. This state is longer than 32 \r\n      // so it must be a custom state. We added 'CUSTOM' prefix and a random 32 byte long\r\n      // string in front of the original custom state, now we change it back.\r\n      if (!source.state.startsWith('CUSTOM'))\r\n        return next(new Error(`In collectInfoFromReq: invalid custom state ${state}`));\r\n\r\n      source.state = source.state.substring(38);\r\n    }\r\n  }\r\n\r\n  // -------------------------------------------------------------------------\r\n  // If we received code, id_token or err, we must have received state, now we\r\n  // find the state/nonce/policy tuple from session.\r\n  // If we received none of them, find policy in query       \r\n  // -------------------------------------------------------------------------\r\n  if (params.id_token || params.code || params.err) {\r\n    if (!params.state)\r\n      return next(new Error('In collectInfoFromReq: missing state in the request'));\r\n\r\n    var tuple;\r\n\r\n    if (!self._useCookieInsteadOfSession)\r\n      tuple = self._sessionContentHandler.findAndDeleteTupleByState(req, self._key, params.state);\r\n    else\r\n      tuple = self._cookieContentHandler.findAndDeleteTupleByState(req, response, params.state);\r\n\r\n    if (!tuple)\r\n      return next(new Error('In collectInfoFromReq: invalid state received in the request'));\r\n\r\n    params.nonce = tuple['nonce'];\r\n    params.policy = tuple['policy'];\r\n    params.resource = tuple['resource'];\r\n\r\n    // user provided tenantIdOrName will be ignored for redirectUrl, since we saved the one we used in session\r\n    if (params.tenantIdOrName)\r\n      log.info(`user provided tenantIdOrName '${params.tenantIdOrName}' is ignored for redirectUrl, we will use the one stored in session`);\r\n    params.tenantIdOrName = tuple['tenantIdOrName'];\r\n  } else {\r\n    params.policy = req.query.p ? req.query.p.toLowerCase() : null;\r\n  }\r\n\r\n  // if we are not using the common endpoint, but we have tenantIdOrName, just ignore it\r\n  if (!self._options.isCommonEndpoint && params.tenantIdOrName) {\r\n    log.info(`identityMetadata is tenant-specific, so we ignore the tenantIdOrName '${params.tenantIdOrName}'`);\r\n    params.tenantIdOrName = null;\r\n  }\r\n\r\n  // if we are using the common endpoint and we want to validate issuer, then user has to \r\n  // provide issuer in config, or provide tenant id or name using tenantIdOrName option in\r\n  // passport.authenticate. Otherwise we won't know the issuer.\r\n  if (self._options.isCommonEndpoint && self._options.validateIssuer &&\r\n    (!self._options.issuer && !params.tenantIdOrName))\r\n    return next(new Error('In collectInfoFromReq: issuer or tenantIdOrName must be provided in order to validate issuer on common endpoint'));\r\n\r\n  // for B2C, we must have policy\r\n  if (self._options.isB2C && !params.policy)\r\n    return next(new Error('In collectInfoFromReq: policy is missing'));\r\n  // for B2C, if we are using common endpoint, we must have tenantIdOrName provided\r\n  if (self._options.isB2C && self._options.isCommonEndpoint && !params.tenantIdOrName)\r\n    return next(new Error('In collectInfoFromReq: we are using common endpoint for B2C but tenantIdOrName is not provided'));\r\n\r\n  // -------------------------------------------------------------------------\r\n  // calculate metadataUrl, create a cachekey and an Metadata object instance  \r\n  // we will fetch the metadata, save it into the object using the cachekey       \r\n  // -------------------------------------------------------------------------   \r\n  var metadataUrl = self._options.identityMetadata;   \r\n\r\n  // if we are using common endpoint and we are given the tenantIdOrName, let's replace it\r\n  if (self._options.isCommonEndpoint && params.tenantIdOrName) {\r\n    metadataUrl = metadataUrl.replace('/common/', `/${params.tenantIdOrName}/`);\r\n    log.info(`we are replacing 'common' with the tenantIdOrName ${params.tenantIdOrName}`);\r\n  }\r\n\r\n  // add policy for B2C\r\n  if (self._options.isB2C)\r\n    metadataUrl = metadataUrl.concat(`&p=${params.policy}`);\r\n\r\n  // we use the metadataUrl as the cachekey\r\n  params.cachekey = metadataUrl;\r\n  params.metadata = new Metadata(metadataUrl, 'oidc', self._options);\r\n\r\n  log.info(`metadataUrl is: ${metadataUrl}`);\r\n  log.info(`received the following items in params: ${JSON.stringify(params)}`);\r\n\r\n  return next();\r\n};\r\n\r\n/**\r\n * Set the information we need for oauth flow and id_token validation\r\n *\r\n * @param {Object} params             -- parameters we get from the request\r\n * @param {Object} oauthConfig        -- the items we need for oauth flow\r\n * @param {Object} optionsToValidate  -- the items we need to validate id_token\r\n * @param {Function} done             -- the callback \r\n */\r\nStrategy.prototype.setOptions = function setOptions(params, oauthConfig, optionsToValidate, done) {\r\n  const self = this;\r\n\r\n  async.waterfall([\r\n    // ------------------------------------------------------------------------\r\n    // load metadata\r\n    // ------------------------------------------------------------------------\r\n    (next) => {\r\n      memoryCache.wrap(params.cachekey, (cacheCallback) => {\r\n        params.metadata.fetch((fetchMetadataError) => {\r\n          if (fetchMetadataError) {\r\n            return cacheCallback(new Error(`In setOptions: Unable to fetch metadata`)); \r\n          }\r\n          return cacheCallback(null, params.metadata);\r\n        });\r\n      }, { ttl }, next);\r\n    },\r\n\r\n    // ------------------------------------------------------------------------\r\n    // set oauthConfig: the information we need for oauth flow like redeeming code/access_token\r\n    // ------------------------------------------------------------------------\r\n    (metadata, next) => {\r\n      if (!metadata.oidc)\r\n        return next(new Error('In setOptions: failed to load metadata'));\r\n      params.metadata = metadata;\r\n      \r\n      // copy the fields needed into 'oauthConfig'\r\n      aadutils.copyObjectFields(metadata.oidc, oauthConfig, ['authorization_endpoint', 'token_endpoint', 'userinfo_endpoint']);\r\n      aadutils.copyObjectFields(self._options, oauthConfig, ['clientID', 'clientSecret', 'privatePEMKey', 'thumbprint', 'responseType', 'responseMode', 'scope', 'redirectUrl']);\r\n      oauthConfig.tenantIdOrName = params.tenantIdOrName;\r\n      oauthConfig.extraAuthReqQueryParams = params.extraAuthReqQueryParams;\r\n      oauthConfig.extraTokenReqQueryParams = params.extraTokenReqQueryParams;\r\n\r\n      // validate oauthConfig\r\n      const validatorConfig = {\r\n        authorization_endpoint: Validator.isHttpsURL,\r\n        token_endpoint: Validator.isHttpsURL,\r\n        userinfo_endpoint: Validator.isHttpsURLIfExists,\r\n      };\r\n\r\n      try {\r\n        // validator will throw exception if a required option is missing\r\n        const checker = new Validator(validatorConfig);\r\n        checker.validate(oauthConfig);\r\n      } catch (ex) {\r\n        return next(new Error(`In setOptions: ${aadutils.getErrorMessage(ex)}`));\r\n      }\r\n\r\n      // for B2C, verify the endpoints in oauthConfig has the correct policy\r\n      if (self._options.isB2C){\r\n        var policyChecker = (endpoint, policy) => {\r\n          var u = {};          \r\n          try {\r\n            u = url.parse(endpoint, true);\r\n          } catch (ex) {\r\n          }\r\n          return u.query && u.query.p && (policy.toLowerCase() === u.query.p.toLowerCase());\r\n        };\r\n        // B2C has no userinfo_endpoint, so no need to check it\r\n        if (!policyChecker(oauthConfig.authorization_endpoint, params.policy))\r\n          return next(new Error(`policy in ${oauthConfig.authorization_endpoint} should be ${params.policy}`));\r\n        if (!policyChecker(oauthConfig.token_endpoint, params.policy))\r\n          return next(new Error(`policy in ${oauthConfig.token_endpoint} should be ${params.policy}`));\r\n      }\r\n\r\n      return next(null, metadata);\r\n    },\r\n\r\n    // ------------------------------------------------------------------------\r\n    // set optionsToValidate: the information we need for id_token validation.\r\n    // we do this only if params has id_token or code, otherwise there is no\r\n    // id_token to validate\r\n    // ------------------------------------------------------------------------\r\n    (metadata, next) => {\r\n      if (!params.id_token && !params.code)\r\n        return next(null);\r\n\r\n      // set items from self._options\r\n      aadutils.copyObjectFields(self._options, optionsToValidate, \r\n        ['validateIssuer', 'audience', 'allowMultiAudiencesInToken', 'ignoreExpiration', 'allowMultiAudiencesInToken']);\r\n\r\n      // algorithms\r\n      var algorithms = metadata.oidc.algorithms;\r\n      if (!algorithms)\r\n        return next(new Error('In setOptions: algorithms is missing in metadata'));\r\n      if (!Array.isArray(algorithms) || algorithms.length == 0 || (algorithms.length === 1 && algorithms[0] === 'none'))\r\n        return next(new Error('In setOptions: algorithms must be an array containing at least one algorithm'));\r\n      optionsToValidate.algorithms = algorithms;\r\n\r\n      // nonce\r\n      optionsToValidate.nonce = params.nonce;\r\n\r\n      // clock skew\r\n      optionsToValidate.clockSkew = self._options.clockSkew;\r\n\r\n      // jweKeyStore\r\n      optionsToValidate.jweKeyStore = self._options.jweKeyStore;\r\n\r\n      // issuer\r\n      // if the metadata is not coming from common endpoint, we record the issuer value from metadata\r\n      if (!self._options.isCommonEndpoint || (self._options.isCommonEndpoint && params.tenantIdOrName))\r\n        optionsToValidate.issuer = [metadata.oidc.issuer];\r\n      else\r\n        optionsToValidate.issuer = [];\r\n      // if user provided issuer, we also record these issuer values\r\n      if (self._options.issuer)\r\n        optionsToValidate.issuer = optionsToValidate.issuer.concat(self._options.issuer);\r\n      // if we don't get any issuer value and we want to validate issuer, we should fail\r\n      if (optionsToValidate.issuer.length === 0 && self._options.validateIssuer)\r\n        return next(new Error('In setOptions: we want to validate issuer but issuer is not found'));\r\n\r\n      return next(null);\r\n    },\r\n  ], done);\r\n};\r\n\r\n/**\r\n * validate id_token, and pass the validated claims and the payload to callback\r\n * if code (resp. access_token) is provided, we will validate the c_hash (resp at_hash) as well\r\n *\r\n * @param {String} params\r\n * @param {String} optionsToValidate\r\n * @param {Object} req\r\n * @param {Function} next  -- when error occurs, call next(err)\r\n * @param {Function} callback\r\n */\r\nStrategy.prototype._idTokenHandler = function idTokenHandler(params, optionsToValidate, req, next, callback) {\r\n  const self = this;\r\n\r\n  var id_token = params.id_token;\r\n  var parts = id_token.split('.');\r\n\r\n  if (parts.length === 3)\r\n    return self._validateResponse(params, optionsToValidate, req, next, callback);\r\n  else if (parts.length === 5) {\r\n    log.info('In _idTokenHandler: we received an id_token of JWE format, we are decrypting it');\r\n    var decrypted_token;\r\n\r\n    return jwe.decrypt(id_token, optionsToValidate.jweKeyStore, log, (err, decrypted_token) => {\r\n      if(err)\r\n        return next(err);\r\n\r\n      params.id_token = decrypted_token;\r\n      return self._validateResponse(params, optionsToValidate, req, next, callback);\r\n    });\r\n  } else\r\n    return next(new Error(`id_token has ${parts.length} parts, it is neither jwe nor jws`));\r\n};\r\n\r\n/**\r\n * validate id_token, and pass the validated claims and the payload to callback\r\n * if code (resp. access_token) is provided, we will validate the c_hash (resp at_hash) as well\r\n *\r\n * @param {String} params\r\n * @param {String} optionsToValidate\r\n * @param {Object} req\r\n * @param {Function} next  -- when error occurs, call next(err)\r\n * @param {Function} callback\r\n */\r\nStrategy.prototype._validateResponse = function validateResponse(params, optionsToValidate, req, next, callback) {\r\n  const self = this;\r\n\r\n  var id_token = params.id_token;\r\n  var code = params.code;\r\n  var access_token = params.access_token;\r\n\r\n  // decode id_token\r\n  const decoded = jws.decode(id_token);\r\n  if (decoded == null)\r\n    return next(new Error('In _validateResponse: Invalid JWT token'));\r\n\r\n  log.info('token decoded: ', decoded);\r\n\r\n  // get Pem Key\r\n  var PEMkey = null;\r\n  if (decoded.header.kid) {\r\n    PEMkey = params.metadata.generateOidcPEM(decoded.header.kid);\r\n  } else if (decoded.header.x5t) {\r\n    PEMkey = params.metadata.generateOidcPEM(decoded.header.x5t);\r\n  } else {\r\n    return next(new Error('In _validateResponse: We did not receive a token we know how to validate'));\r\n  }\r\n  log.info('PEMkey generated: ' + PEMkey);\r\n\r\n  // verify id_token signature and claims\r\n  return jwt.verify(id_token, PEMkey, optionsToValidate, (err, jwtClaims) => {\r\n    if (err)\r\n      return next(new Error(`In _validateResponse: ${aadutils.getErrorMessage(err)}`));\r\n\r\n    log.info(\"Claims received: \", jwtClaims);\r\n\r\n    // jwt checks the 'nbf', 'exp', 'aud', 'iss' claims\r\n    // there are a few other things we will check below\r\n\r\n    // For B2C, check the policy\r\n    if (self._options.isB2C) {\r\n      var policy_in_idToken;\r\n\r\n      if (jwtClaims.acr && CONSTANTS.POLICY_REGEX.test(jwtClaims.acr))\r\n        policy_in_idToken = jwtClaims.acr;\r\n      else if (jwtClaims.tfp && CONSTANTS.POLICY_REGEX.test(jwtClaims.tfp))\r\n        policy_in_idToken = jwtClaims.tfp.toLowerCase();\r\n      else\r\n        return next(new Error('In _validateResponse: invalid B2C policy in id_token'));\r\n\r\n      if (params.policy !== policy_in_idToken)\r\n        return next(new Error(\"In _validateResponse: policy in id_token does not match the policy used\"));\r\n    }\r\n\r\n    // check nonce\r\n    if (!jwtClaims.nonce || jwtClaims.nonce === '' || jwtClaims.nonce !== optionsToValidate.nonce)\r\n      return next(new Error('In _validateResponse: invalid nonce'));\r\n\r\n    // check c_hash\r\n    if (jwtClaims.c_hash) {\r\n      // checkHashValueRS256 checks if code is null, so we don't bother here\r\n      if (!aadutils.checkHashValueRS256(code, jwtClaims.c_hash)) \r\n        return next(new Error(\"In _validateResponse: invalid c_hash\"));\r\n    }\r\n\r\n    // check at_hash\r\n    if (jwtClaims.at_hash) {\r\n      // checkHashValueRS256 checks if access_token is null, so we don't bother here\r\n      if (!aadutils.checkHashValueRS256(access_token, jwtClaims.at_hash))\r\n        return next(new Error(\"In _validateResponse: invalid at_hash\"));\r\n    }\r\n\r\n    // return jwt claims and jwt claims string\r\n    var idTokenSegments = id_token.split('.');\r\n    var jwtClaimsStr = base64url.decode(idTokenSegments[1]);\r\n    return callback(jwtClaimsStr, jwtClaims);\r\n  });\r\n};\r\n\r\n/**\r\n * handle error response\r\n *\r\n * @params {String} err \r\n * @params {String} err_description\r\n * @params {Function} next  -- callback to pass error to async.waterfall\r\n */\r\nStrategy.prototype._errorResponseHandler = function errorResponseHandler(err, err_description, next) {\r\n  const self = this;\r\n\r\n  log.info('Error received in the response was: ', err);\r\n  if (err_description)\r\n    log.info('Error description received in the response was: ', err_description);\r\n\r\n  // Unfortunately, we cannot return the 'error description' to the user, since \r\n  // it goes to http header by default and it usually contains characters that\r\n  // http header doesn't like, which causes the program to crash. \r\n  return next(new Error(err));\r\n};\r\n\r\n/**\r\n * handle the response where we only get 'id_token' in the response\r\n *\r\n * @params {Object} params\r\n * @params {Object} optionsToValidate \r\n * @params {Object} req\r\n * @params {Function} next  -- callback to pass error to async.waterfall\r\n */\r\nStrategy.prototype._implicitFlowHandler = function implicitFlowHandler(params, optionsToValidate, req, next) {\r\n  /* we will do the following things in order\r\n   * (1) validate id_token\r\n   * (2) use the claims in the id_token for user's profile\r\n   */\r\n\r\n  const self = this;\r\n\r\n  log.info('entering Strategy.prototype._implicitFlowHandler, received id_token: ' + params.id_token);\r\n\r\n  // validate the id_token\r\n  return self._idTokenHandler(params, optionsToValidate, req, next, (jwtClaimsStr, jwtClaims) => {\r\n    const sub = jwtClaims.sub;\r\n    const iss = jwtClaims.iss;\r\n\r\n    log.info('we are in implicit flow, use the content in id_token as the profile');\r\n\r\n    return onProfileLoaded(self, {\r\n      req,\r\n      sub,\r\n      iss,\r\n      profile: makeProfileObject(jwtClaims, jwtClaimsStr),\r\n      jwtClaims,\r\n      access_token: null,\r\n      refresh_token: null,\r\n      params: null\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * handle the response where we get 'id_token' and 'code' in the response\r\n *\r\n * @params {Object} params\r\n * @params {Object} oauthConfig\r\n * @params {Object} optionsToValidate \r\n * @params {Object} req\r\n * @params {Function} next  -- callback to pass error to async.waterfall\r\n */\r\nStrategy.prototype._hybridFlowHandler = function hybridFlowHandler(params, oauthConfig, optionsToValidate, req, next) {\r\n  /* we will do the following things in order\r\n   * (1) validate the id_token and the code\r\n   * (2) if there is no userinfo token needed (or ignored if using AAD v2 ), we use \r\n   *     the claims in id_token for user's profile\r\n   * (3) if userinfo token is needed, we will use the 'code' and the authorization code flow\r\n   */\r\n  const self = this;\r\n\r\n  log.info('entering Strategy.prototype._hybridFlowHandler, received code: ' + params.code + ', received id_token: ' + params.id_token);\r\n\r\n  // save nonce, since if we use the authorization code flow later, we have to check \r\n  // nonce again.\r\n\r\n  // validate the id_token and the code\r\n  return self._idTokenHandler(params, optionsToValidate, req, next, (jwtClaimsStr, jwtClaims) => {\r\n    // c_hash is required for 'code id_token' flow. If we have c_hash, then _validateResponse already\r\n    // validates it; otherwise, _validateResponse ignores the c_hash check, and we check here\r\n    if (!jwtClaims.c_hash)\r\n      return next(new Error(\"In _hybridFlowHandler: we are in hybrid flow using code id_token, but c_hash is not found in id_token\"));\r\n\r\n    const sub = jwtClaims.sub;\r\n    const iss = jwtClaims.iss;\r\n\r\n    // now we use the authorization code flow\r\n    return self._authCodeFlowHandler(params, oauthConfig, optionsToValidate, req, next, iss, sub);\r\n  });\r\n};\r\n\r\n/**\r\n * handle the response where we only get 'code' in the response\r\n *\r\n * @params {Object} params\r\n * @params {Object} oauthConfig\r\n * @params {Object} optionsToValidate \r\n * @params {Object} req\r\n * @params {Function} next  -- callback to pass error to async.waterfall\r\n * // the following are required if you used 'code id_token' flow then call this function to \r\n * // redeem the code for another id_token from the token endpoint. iss and sub are those \r\n * // in the id_token from authorization endpoint, and they should match those in the id_token\r\n * // from the token endpoint \r\n * @params {String} iss\r\n * @params {String} sub\r\n */\r\nStrategy.prototype._authCodeFlowHandler = function authCodeFlowHandler(params, oauthConfig, optionsToValidate, req, next, iss, sub) {\r\n  /* we will do the following things in order:\r\n   * (1) use code to get id_token and access_token\r\n   * (2) validate the id_token and the access_token received\r\n   * (3) if user asks for userinfo and we are using AAD v1, then we use access_token to get\r\n   *     userinfo, then make sure the userinfo has the same 'sub' as that in the 'id_token'\r\n   */\r\n  const self = this;\r\n  var code = params.code;\r\n\r\n  log.info('entering Strategy.prototype._authCodeFlowHandler, received code: ' + code);\r\n\r\n  var issFromPrevIdToken = iss;\r\n  var subFromPrevIdToken = sub;\r\n\r\n  return self._getAccessTokenBySecretOrAssertion(code, oauthConfig, next, (getOAuthAccessTokenError, items) => {\r\n    if (getOAuthAccessTokenError)\r\n      return next(new Error(`In _authCodeFlowHandler: failed to redeem authorization code: ${aadutils.getErrorMessage(getOAuthAccessTokenError)}`));\r\n\r\n    var access_token = items.access_token;\r\n    var refresh_token = items.refresh_token;\r\n\r\n    // id_token should be present\r\n    if (!items.id_token)\r\n      return next(new Error('In _authCodeFlowHandler: id_token is not received'));\r\n\r\n    // token_type must be 'Bearer' ignoring the case\r\n    if (items.token_type.toLowerCase() !== 'bearer') {\r\n      log.info('token_type received is: ', items.token_type);\r\n      return next(new Error(`In _authCodeFlowHandler: token_type received is not 'Bearer' ignoring the case`));\r\n    }\r\n\r\n    log.info('received id_token: ', items.id_token);\r\n    log.info('received access_token: ', access_token);\r\n    log.info('received refresh_token: ', refresh_token);\r\n\r\n    // validate id_token and access_token, so put them into params\r\n    params.access_token = access_token;\r\n    params.id_token = items.id_token;\r\n\r\n    return self._idTokenHandler(params, optionsToValidate, req, next, (jwtClaimsStr, jwtClaims) => {\r\n      // for 'code id_token' flow, check iss/sub in the id_token from the authorization endpoint\r\n      // with those in the id_token from token endpoint\r\n      if (issFromPrevIdToken && issFromPrevIdToken !== jwtClaims.iss)\r\n        return next(new Error('In _authCodeFlowHandler: After redeeming the code, iss in id_token from authorize_endpoint does not match iss in id_token from token_endpoint'));\r\n      if (subFromPrevIdToken && subFromPrevIdToken !== jwtClaims.sub)\r\n        return next(new Error('In _authCodeFlowHandler: After redeeming the code, sub in id_token from authorize_endpoint does not match sub in id_token from token_endpoint'));\r\n\r\n      const sub = jwtClaims.sub;\r\n      const iss = jwtClaims.iss;\r\n      \r\n      // load the userinfo, if this is not v2 and if we don't specify the resource\r\n      // for v1 if we don't specify the resource, then the access_token we got is for userinfo endpoint, so we can use it to get userinfo \r\n      if (!self._options._isV2 && !params.resource) {\r\n        // make sure we get an access_token\r\n        if (!access_token)\r\n          return next(new Error(\"In _authCodeFlowHandler: we want to access userinfo endpoint, but access_token is not received\"));\r\n\r\n        let parsedUrl;\r\n        try {\r\n          parsedUrl = url.parse(oauthConfig.userinfo_endpoint, true);\r\n        } catch (urlParseException) {\r\n          return next(new Error(`In _authCodeFlowHandler: Failed to parse config property 'userInfoURL' with value ${oauthConfig.userinfo_endpoint}`));\r\n        }\r\n\r\n        parsedUrl.query.schema = 'openid';\r\n        delete parsedUrl.search; // delete operations are slow; should we rather just overwrite it with {}\r\n        const userInfoURL = url.format(parsedUrl);\r\n\r\n        // ask oauth2 to use authorization header to bearer access token\r\n        var oauth2 = createOauth2Instance(oauthConfig);\r\n        oauth2.useAuthorizationHeaderforGET(true);\r\n        return oauth2.get(userInfoURL, access_token, (getUserInfoError, body) => {\r\n          if (getUserInfoError)\r\n            return next(new Error(`In _authCodeFlowHandler: failed to fetch user profile: ${aadutils.getErrorMessage(getUserInfoError)}`));\r\n\r\n          log.info('Profile loaded from MS identity', body);\r\n\r\n          var userinfoReceived = null;\r\n          // use try / catch around JSON.parse --> could fail unexpectedly\r\n          try {\r\n            userinfoReceived = JSON.parse(body);\r\n          } catch (ex) {\r\n            return next(new Error(`In _authCodeFlowHandler: failed to parse userinfo ${body}, due to ${aadutils.getErrorMessage(ex)}`));\r\n          }\r\n\r\n          // make sure the 'sub' in userinfo is the same as the one in 'id_token'\r\n          if (userinfoReceived.sub !== jwtClaims.sub)\r\n            return next(new Error('In _authCodeFlowHandler: sub received in userinfo and id_token do not match'));\r\n\r\n          return onProfileLoaded(self, {\r\n            req,\r\n            sub,\r\n            iss,\r\n            profile: makeProfileObject(userinfoReceived, body),\r\n            jwtClaims,\r\n            access_token,\r\n            refresh_token,\r\n            params: items,\r\n          });\r\n        });\r\n      } else {\r\n        // v2 doesn't have userinfo endpoint, so we use the content in id_token as the profile\r\n        log.info('v2 has no userinfo endpoint, using the content in id_token as the profile');\r\n\r\n        return onProfileLoaded(self, {\r\n          req,\r\n          sub,\r\n          iss,\r\n          profile: makeProfileObject(jwtClaims, jwtClaimsStr),\r\n          jwtClaims,\r\n          access_token,\r\n          refresh_token,\r\n          params: items,\r\n        });\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * prepare the initial authorization request\r\n *\r\n * @params {Object} oauthConfig\r\n * @params {Object} req\r\n * @params {Function} next  -- callback to pass error to async.waterfall\r\n */\r\nStrategy.prototype._flowInitializationHandler = function flowInitializationHandler(oauthConfig, req, next) {\r\n  // The request being authenticated is initiating OpenID Connect\r\n  // authentication. Prior to redirecting to the provider, configuration will\r\n  // be loaded. The configuration is typically either pre-configured or\r\n  // discovered dynamically. When using dynamic discovery, a user supplies\r\n  // their identifer as input.\r\n\r\n  const self = this;\r\n\r\n  log.info(`entering Strategy.prototype._flowInitializationHandler`);\r\n\r\n  const params = {\r\n    'redirect_uri': oauthConfig.redirectUrl,\r\n    'response_type': oauthConfig.responseType,\r\n    'response_mode': oauthConfig.responseMode,\r\n    'client_id': oauthConfig.clientID\r\n  };\r\n\r\n  log.info('We are sending the response_type: ', params.response_type);\r\n  log.info('We are sending the response_mode: ', params.response_mode);\r\n\r\n  if (oauthConfig.domain_hint)\r\n    params['domain_hint'] = oauthConfig.domain_hint;\r\n  if (oauthConfig.login_hint)\r\n    params['login_hint'] = oauthConfig.login_hint;\r\n  if (oauthConfig.prompt)\r\n    params['prompt'] = oauthConfig.prompt;\r\n  if (oauthConfig.extraAuthReqQueryParams) {\r\n    // copy the extra query parameters into params\r\n    for (var attributeName in oauthConfig.extraAuthReqQueryParams) {\r\n      if (oauthConfig.extraAuthReqQueryParams.hasOwnProperty(attributeName))\r\n        params[attributeName] = oauthConfig.extraAuthReqQueryParams[attributeName];\r\n    }\r\n  }\r\n\r\n  var policy = null;\r\n  if (self._options.isB2C) {\r\n    if (!req.query.p || req.query.p === '')\r\n      return next(new Error('In _flowInitializationHandler: missing policy in the request for B2C'));\r\n    // policy is not case sensitive. AAD turns policy to lower case.\r\n    policy = req.query.p.toLowerCase();\r\n    if (!policy || !CONSTANTS.POLICY_REGEX.test(policy))\r\n      return next(new Error(`In _flowInitializationHandler: the given policy ${policy} given in the request is invalid`));\r\n  }\r\n\r\n  // add state/nonce/policy/timeStamp tuple to session or cookie\r\n  let state = params.state = oauthConfig.customState ? ('CUSTOM' + aadutils.uid(32) + oauthConfig.customState) : aadutils.uid(32);\r\n  let nonce = params.nonce = aadutils.uid(32);\r\n  let resource = oauthConfig.resource ? oauthConfig.resource : null;\r\n  if (resource)\r\n    params.resource = resource;\r\n\r\n  var tuple = { state: state, nonce: nonce };\r\n  if (policy)\r\n    tuple.policy = policy;\r\n  if (resource)\r\n    tuple.resource = resource;\r\n  if (oauthConfig.tenantIdOrName)\r\n    tuple.tenantIdOrName = oauthConfig.tenantIdOrName;\r\n\r\n  if (!self._useCookieInsteadOfSession) {\r\n    tuple.timeStamp = Date.now();\r\n    self._sessionContentHandler.add(req, self._key, tuple);\r\n  } else {\r\n    // we don't need to record timestamp if we use cookie, since we can set the\r\n    // expiration when we set cookie\r\n    self._cookieContentHandler.add(req, oauthConfig.response, tuple);\r\n  }\r\n  \r\n  // add scope\r\n  params.scope = oauthConfig.scope;\r\n\r\n  // add telemetry\r\n  params[aadutils.getLibraryProductParameterName()] = aadutils.getLibraryProduct();\r\n  params[aadutils.getLibraryVersionParameterName()] = aadutils.getLibraryVersion();\r\n  let location;\r\n\r\n  // Implement support for standard OpenID Connect params (display, prompt, etc.)\r\n  if (self._options.isB2C)\r\n    location = `${oauthConfig.authorization_endpoint}&${querystring.stringify(params)}`;\r\n  else\r\n    location = `${oauthConfig.authorization_endpoint}?${querystring.stringify(params)}`;\r\n\r\n  return self.redirect(location);\r\n};\r\n\r\n/**\r\n * get access_token using client secret or client assertion\r\n *\r\n * @params {String} code\r\n * @params {Object} oauthConfig\r\n * @params {Function} callback\r\n */\r\nStrategy.prototype._getAccessTokenBySecretOrAssertion = (code, oauthConfig, next, callback) => {\r\n  var post_headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\r\n\r\n  var post_params = {\r\n    code: code,\r\n    client_id: oauthConfig.clientID,\r\n    redirect_uri: oauthConfig.redirectUrl,\r\n    scope: oauthConfig.scope,\r\n    grant_type: 'authorization_code'\r\n  };\r\n\r\n  if (oauthConfig.extraTokenReqQueryParams) {\r\n    // copy the extra query parameters into post_params\r\n    for (var attributeName in oauthConfig.extraTokenReqQueryParams) {\r\n      if (oauthConfig.extraTokenReqQueryParams.hasOwnProperty(attributeName))\r\n        post_params[attributeName] = oauthConfig.extraTokenReqQueryParams[attributeName];\r\n    }\r\n  }\r\n\r\n  if (oauthConfig.clientSecret) {\r\n    // use client secret if it exists\r\n    post_params['client_secret'] = oauthConfig.clientSecret;\r\n    log.info('In _getAccessTokenBySecretOrAssertion: we are using client secret');\r\n  } else {\r\n    // otherwise generate a client assertion\r\n    post_params['client_assertion_type'] = CONSTANTS.CLIENT_ASSERTION_TYPE;   \r\n\r\n    jwt.generateClientAssertion(oauthConfig.clientID, oauthConfig.token_endpoint, oauthConfig.privatePEMKey, oauthConfig.thumbprint,\r\n      (err, assertion) => {\r\n        if (err)\r\n          return next(err);\r\n        else\r\n          post_params['client_assertion'] = assertion;\r\n    });\r\n\r\n    log.info('In _getAccessTokenBySecretOrAssertion: we created a client assertion with thumbprint ' + oauthConfig.thumbprint);\r\n  };\r\n\r\n  var post_data = querystring.stringify(post_params);\r\n\r\n  var oauth2 = createOauth2Instance(oauthConfig);\r\n\r\n  oauth2._request('POST', oauthConfig.token_endpoint, post_headers, post_data, null, (error, data, response) => {\r\n    if (error) callback(error);\r\n    else {\r\n      var results;\r\n      try {\r\n        results = JSON.parse(data);\r\n      } catch(e) {\r\n        results = querystring.parse(data);\r\n      }\r\n      callback(null, results);\r\n    }\r\n  });   \r\n};\r\n\r\n/**\r\n * fail and log the given message\r\n *\r\n * @params {String} message\r\n */\r\nStrategy.prototype.failWithLog = function(message) {\r\n  this.log.info(`authentication failed due to: ${message}`);\r\n  return this.fail(message);\r\n};\r\n\r\n/**\r\n * create an oauth2 instance\r\n *\r\n * @params {Object} oauthConfig\r\n */\r\nvar createOauth2Instance = function(oauthConfig) {\r\n  let libraryVersion = aadutils.getLibraryVersion();\r\n  let libraryVersionParameterName = aadutils.getLibraryVersionParameterName();\r\n  let libraryProduct = aadutils.getLibraryProduct();\r\n  let libraryProductParameterName = aadutils.getLibraryProductParameterName();\r\n\r\n  var oauth2 = new OAuth2(\r\n    oauthConfig.clientID, // consumerKey\r\n    oauthConfig.clientSecret, // consumer secret\r\n    '', // baseURL (empty string because we use absolute urls for authorize and token paths)\r\n    oauthConfig.authorization_endpoint, // authorizePath\r\n    oauthConfig.token_endpoint, // accessTokenPath\r\n    {libraryProductParameterName : libraryProduct,\r\n     libraryVersionParameterName : libraryVersion} // customHeaders\r\n  );\r\n\r\n  return oauth2;\r\n};\r\n\r\nmodule.exports = Strategy;\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/jwe.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n \r\n /* eslint-disable no-new */\r\n\r\n'use strict';\r\n\r\nvar crypto = require('crypto');\r\nvar constants = require('constants');\r\nconst base64url = require('base64url');\r\n\r\nvar aadutils = require('./aadutils');\r\nvar jwkToPem = require('jwk-to-pem');\r\n\r\n/******************************************************************************\r\n * utility functions\r\n *****************************************************************************/\r\n\r\n/**\r\n * Create a buffer depends on the version of node\r\n *\r\n * @param{Buffer/String/Number}  data: buffer, string, or size\r\n * @param{String}  encoding: ignored if data is a buffer\r\n * @return{Buffer} \r\n */\r\nvar createBuffer = (data, encoding) => {\r\n  if (!Buffer.isBuffer(data) && typeof data !== 'string' && typeof data !== 'number')\r\n    throw new Error('in createBuffer, data must be a buffer, string or number');\r\n\r\n  if (process.version >= 'v6') {\r\n    if (typeof data === 'string')\r\n      return Buffer.from(data, encoding);\r\n    else if (typeof data === 'number')\r\n      return Buffer.alloc(data);\r\n    else\r\n      return Buffer.from(data);\r\n  } else {\r\n    if (typeof data === 'string')\r\n      return new Buffer(data, encoding);\r\n    else\r\n      return new Buffer(data);\r\n  } \r\n};\r\n\r\n/**\r\n * xor of two number in buffer format\r\n *\r\n * @param{Buffer}  a: first number\r\n * @param{Buffer}  b: second number\r\n * @return{Buffer}  a^b\r\n */\r\nvar xor = (a, b) => {\r\n  var c1, c2;\r\n  if (a.length > b.length) {\r\n    c1 = a; c2 = b;\r\n  } else {\r\n    c2 = a; c1 = b;\r\n  }\r\n  var c = createBuffer(c1);\r\n  for (var i = 1; i <= c2.length; i++)\r\n    c[c1.length-i] = c[c1.length-i] ^ c2[c2.length-i];\r\n  return c;\r\n};\r\n\r\n/******************************************************************************\r\n * AES key unwrap algorithms\r\n *****************************************************************************/\r\n\r\n/**\r\n * Unwrap wrapped_cek using AES with kek\r\n *\r\n * @param{String}  algorithm: algorithm\r\n * @param{Buffer}  wrapped_cek: wrapped key\r\n * @param{Buffer}  kek: key encryption key\r\n * @return{Buffer}  cek, the unwrapped key\r\n */\r\nvar AESKeyUnWrap = (algorithm, wrapped_cek, kek) => {\r\n\r\n  /****************************************************************************\r\n   * Inputs: CipherText, (n+1) 64-bit values {C0, C1, ..., Cn}, and \r\n   *         Key, K (the KEK)\r\n   * Outputs: Plaintext, n 64-bit values {P0, P1, K, Pn}\r\n   ***************************************************************************/\r\n  var C = wrapped_cek;\r\n  var n = C.length/8-1;\r\n  var K = kek;\r\n\r\n  /****************************************************************************\r\n   * 1) Initialize variables\r\n   *    Set A = C[0]\r\n   *    For i = 1 to b\r\n   *      R[i] = C[i]\r\n   ***************************************************************************/\r\n  var A = C.slice(0,8);\r\n  var R = [createBuffer(1)];\r\n  for (var i = 1; i <= n; i++)\r\n    R.push(C.slice(8*i, 8*i+8));\r\n\r\n  /****************************************************************************\r\n   * 2) compute intermediate values\r\n   *    For j = 5 to 0\r\n   *      For i = n to 1\r\n   *        B = AES-1(K, (A^t) | R[i]) where t = n*j+i\r\n   *        A = MSB(64, B)\r\n   *        R[i] = LSB(64, B)\r\n   ***************************************************************************/\r\n  for(var j=5; j >= 0; j--) {\r\n    for(var i=n; i >= 1; i--) {\r\n      // turn t = n*j+i into buffer\r\n      var str = (n*j+i).toString(16);\r\n      if (str.length %2 !== 0)\r\n        str = '0' + str;\r\n      var t = createBuffer(str, 'hex');\r\n\r\n      // B = AES-1(K, (A^t) | R[i])\r\n      var aes = crypto.createDecipheriv(algorithm, K, '');\r\n      aes.setAutoPadding(false);\r\n      var B = aes.update(Buffer.concat([xor(A, t), R[i]]), null, 'hex');\r\n      B += aes.final('hex');\r\n      B = createBuffer(B, 'hex');\r\n\r\n      // A = MSB(64, B)\r\n      A = B.slice(0, 8);\r\n\r\n      // R[i] = LSB(64, B)\r\n      R[i] = B.slice(B.length-8);\r\n    }\r\n  }\r\n\r\n  /****************************************************************************\r\n   * 3) Output results.\r\n   *    If A is an appropriate initial value\r\n   *    Then\r\n   *      For i = 1 to n\r\n   *        P[i] = R[i]\r\n   *    Else\r\n   *      Return an error\r\n   ***************************************************************************/\r\n  \r\n  // check A\r\n  if (A.toString('hex').toUpperCase() === 'A6A6A6A6A6A6A6A6') {\r\n    var result = R[1];\r\n    for (var i = 2; i <= n; i++)\r\n      result = Buffer.concat([result, R[i]]);\r\n    \r\n    return result;\r\n  } else {\r\n    throw new Error('aes decryption failed: invalid key');\r\n  }\r\n};\r\n\r\n/******************************************************************************\r\n * AES-CBC-HMAC-SHA2 decryption\r\n *****************************************************************************/\r\n\r\n/**\r\n * decrypt ciperText using aes-cbc-hmac-sha2 algorithm\r\n *\r\n * @param{String}  algorithm: algorithm\r\n * @param{Buffer}  key: encryption key\r\n * @param{Buffer}  cipherText: encrypted content\r\n * @param{Buffer}  iv: intialization vector\r\n * @param{Buffer}  aad: additional authentication data\r\n * @param{Buffer}  authTag: authentication tag\r\n * @return{Buffer}  decrypted content\r\n */\r\nvar decrypt_AES_CBC_HMAC_SHA2 = (algorithm, key, cipherText, iv, aad, authTag) => {\r\n  // algorithm information\r\n  // note ENC_KEY_LEN = MAC_KEY_LEN = T_LEN = len\r\n  var algInfo = {\r\n    'aes-128-cbc-hmac-sha-256': {\r\n        'cipher_algo': 'aes-128-cbc', \r\n        'hash_algo': 'sha256', \r\n        'len': 16\r\n      },\r\n    'aes-192-cbc-hmac-sha-384': {\r\n        'cipher_algo': 'aes-192-cbc', \r\n        'hash_algo': 'sha384', \r\n        'len': 24\r\n      },\r\n    'aes-256-cbc-hmac-sha-512': {\r\n        'cipher_algo': 'aes-256-cbc', \r\n        'hash_algo': 'sha512', \r\n        'len': 32\r\n      }\r\n  };\r\n\r\n  // 1. Verify input\r\n\r\n  // check if we have a supported algorithm\r\n  if (!algorithm)\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: algorithm is not provided');\r\n  if (!algInfo[algorithm])\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: unsupported algorithm: ' + algorithm);\r\n\r\n  var algo = algInfo[algorithm];\r\n\r\n  // check the size of key\r\n  if (!key)\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: key is not provided');\r\n  if (!(key instanceof Buffer))\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: key must be a buffer');\r\n  if (key.length !== algInfo[algorithm].len * 2)\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: key has size ' + key.length + ', it must have size ' + algo.len * 2);\r\n  \r\n  // check the size of iv\r\n  if (!iv)\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: iv is not provided');\r\n  if (!(iv instanceof Buffer))\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: iv must be a buffer');\r\n  if (iv.length !== 16)\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: iv has size ' + iv.length + ', it must have size 16');\r\n\r\n  // check the existence of aad\r\n  if (!aad)\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: aad is not provided');\r\n  if (!(aad instanceof Buffer))\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: aad must be a buffer');\r\n\r\n  // 2. Split key\r\n\r\n  // first half is mac_key and the second half is enc_key\r\n  var mac_key = key.slice(0, algo.len);\r\n  var enc_key = key.slice(algo.len);\r\n\r\n  // 3. Verify tag\r\n\r\n  // tag should be: hash(aad + iv + cipherText + aad_len) where aad_len is the\r\n  // number of bits in aad expressed as a 64-bit unsigned big-endian integer\r\n\r\n  // 3.1 compute aad_len\r\n  var aad_len = createBuffer(8);\r\n  aad_len.writeUInt32BE(aad.length * 8, 4);\r\n  aad_len.writeUInt32BE(0, 0);\r\n\r\n  // 3.2 create hmac algorithm\r\n  var hmac = crypto.createHmac(algo.hash_algo, mac_key);\r\n  hmac.write(aad);\r\n  hmac.write(iv);\r\n  hmac.update(cipherText);\r\n  hmac.update(aad_len);\r\n  var computed_authTag = hmac.digest().slice(0, algo.len);\r\n\r\n  // 3.3 verify the tag\r\n  if (!authTag || !computed_authTag || (authTag.toString('hex') !== computed_authTag.toString('hex')))\r\n    throw new Error('In decrypt_AES_CBC_HMAC_SHA2: invalid authentication tag');\r\n\r\n  // 4. Decrypt cipherText\r\n  var decipher = crypto.createDecipheriv(algo.cipher_algo, enc_key, iv);\r\n  var plainText = decipher.update(cipherText);\r\n  plainText = Buffer.concat([plainText, decipher.final()]);\r\n  \r\n  return plainText;\r\n};\r\n\r\n\r\n/******************************************************************************\r\n * JWE decryption\r\n *****************************************************************************/\r\n\r\n/**\r\n * decrypt cek helper function\r\n *\r\n * @param{String}  alg: algorithm\r\n * @param{Buffer}  encrypted_cek: encrypted cek\r\n * @param{Buffer}  key: encryption key\r\n * @return{Function}  log: logging function\r\n */\r\nvar decryptCEKHelper = (alg, encrypted_cek, key, log) => {\r\n  var error = null;\r\n  var cek = null;\r\n\r\n  try {\r\n    var key_to_use;\r\n\r\n    if (alg === 'RSA1_5' || alg === 'RSA-OAEP') {\r\n      if (key['privatePemKey']) {\r\n        log.info('using RSA privatePemKey to decrypt cek');\r\n        key_to_use = key['privatePemKey'];\r\n      } else {\r\n        log.info('converting jwk to RSA privatePemKey to decrypt cek');\r\n        key_to_use = jwkToPem(key, {private: true});\r\n      }\r\n    } else if (alg === 'A128KW' || alg === 'A256KW') {\r\n      log.info('using symmetric key to decrypt cek');\r\n      key_to_use = base64url.toBuffer(key.k);\r\n    } else {\r\n      log.info('unsupported alg: ' + alg);\r\n      return {'error': error, 'cek': null};\r\n    }\r\n\r\n    if (alg === 'RSA1_5')\r\n      cek = crypto.privateDecrypt({ key: key_to_use, padding: constants.RSA_PKCS1_PADDING }, encrypted_cek);\r\n    else if (alg === 'RSA-OAEP')\r\n      cek = crypto.privateDecrypt({ key: key_to_use, padding: constants.RSA_PKCS1_OAEP_PADDING }, encrypted_cek);\r\n    else if (alg === 'A128KW')\r\n      cek = AESKeyUnWrap('aes-128-ecb', encrypted_cek, key_to_use);\r\n    else if (alg === 'A256KW')\r\n      cek = AESKeyUnWrap('aes-256-ecb', encrypted_cek, key_to_use);\r\n    else\r\n      cek = key_to_use;  // dir \r\n  } catch (ex) {\r\n    error = ex;\r\n  }\r\n\r\n  return {'error': error, 'cek': cek};\r\n};\r\n\r\n/**\r\n * decrypt cek function (except header.alg == dir)\r\n *\r\n * @param{Object}  header: header\r\n * @param{Buffer}  encrypted_cek: encrypted cek\r\n * @param{Object}  jweKeyStore: list of keys\r\n * @return{Function}  log: logging function\r\n */\r\nvar decryptCEK = (header, encrypted_cek, jweKeyStore, log) => {\r\n  var algKtyMapper = { 'RSA1_5': 'RSA', 'RSA-OAEP': 'RSA', 'A128KW': 'oct', 'A256KW': 'oct'};\r\n\r\n  if (!header.alg)\r\n    return { 'error': new Error('alg is missing in JWE header'), 'cek': null };\r\n  if(['RSA1_5', 'RSA-OAEP', 'dir', 'A128KW', 'A256KW'].indexOf(header.alg) === -1)\r\n    return { 'error' : new Error('Unsupported alg in JWE header: ' + header.alg), 'cek': null };\r\n\r\n  var key = null;\r\n\r\n  if (header.kid) {\r\n    for (var i = 0; i < jweKeyStore.length; i++) {\r\n      if (header.kid === jweKeyStore[i].kid && algKtyMapper[header.alg] === jweKeyStore[i].kty) {\r\n        key = jweKeyStore[i];\r\n        log.info('found a key matching kid: ' + header.kid);\r\n        return decryptCEKHelper(header.alg, encrypted_cek, key, log);\r\n      }\r\n    }\r\n\r\n    return { 'error': new Error('cannot find a key matching kid: ' + header.kid), 'cek': null };\r\n  }\r\n\r\n  log.info('kid is not provided in JWE header, now we try all the possible keys');\r\n\r\n  // kid matching failed, now we try every possible key\r\n  for(var i = 0; i < jweKeyStore.length; i++) {\r\n    if (jweKeyStore[i].kty === algKtyMapper[header.alg]) {\r\n      var result = decryptCEKHelper(header.alg, encrypted_cek, jweKeyStore[i], log);\r\n      if (!result.error && result.cek)\r\n        return result;\r\n    }\r\n  }\r\n\r\n  return { 'error': new Error('tried all keys to decrypt cek but none of them works'), 'cek': null };\r\n};\r\n\r\n/**\r\n * decrypt content function with provided cek\r\n *\r\n * @param{Object}  header: header\r\n * @param{Buffer}  cek: cek\r\n * @param{Buffer}  cipherText: encrypted content\r\n * @param{Buffer}  iv: initialization vector\r\n * @param{Buffer}  authTag: authentication tag\r\n * @param{Buffer}  aad: additional authentication information\r\n * @return{Function}  log: logging function\r\n */\r\nvar decryptContent = (header, cek, cipherText, iv, authTag, aad, log) => {\r\n  if (!header.enc)\r\n    return { 'error': new Error('enc is missing in JWE header'), 'content': null };\r\n  if (['A128GCM', 'A256GCM', 'A128CBC-HS256', 'A192CBC-HS384', 'A256CBC-HS512'].indexOf(header.enc) === -1)\r\n    return { 'error' : new Error('Unsupported enc in JWE header: ' + header.enc), 'content': null };\r\n\r\n  var mapper = { \r\n    'A128GCM': 'aes-128-gcm', \r\n    'A256GCM': 'aes-256-gcm', \r\n    'A128CBC-HS256': 'aes-128-cbc-hmac-sha-256',\r\n    'A192CBC-HS384': 'aes-192-cbc-hmac-sha-384',\r\n    'A256CBC-HS512': 'aes-256-cbc-hmac-sha-512'\r\n  };\r\n\r\n  try {\r\n    var content = null;\r\n\r\n    if (header.enc === 'A128GCM' || header.enc === 'A256GCM') {\r\n      var decipher = crypto.createDecipheriv(mapper[header.enc], cek, iv);\r\n      decipher.setAAD(aad);\r\n      decipher.setAuthTag(authTag);\r\n      content = decipher.update(cipherText);\r\n      content = Buffer.concat([content, decipher.final()]);\r\n    } else {\r\n      content = decrypt_AES_CBC_HMAC_SHA2(mapper[header.enc], cek, cipherText, iv, aad, authTag);    \r\n    }\r\n\r\n    return { 'error': null, 'content': content.toString() };\r\n  } catch (ex) {\r\n    return { 'error': ex, 'content': null };\r\n  }\r\n};\r\n\r\n/**\r\n * decrypt content function for the case where alg is dir\r\n *\r\n * @param{Object}  header: header\r\n * @param{Buffer}  jweKeyStore: list of keys\r\n * @param{Buffer}  cipherText: encrypted content\r\n * @param{Buffer}  iv: initialization vector\r\n * @param{Buffer}  authTag: authentication tag\r\n * @param{Buffer}  aad: additional authentication information\r\n * @return{Function}  log: logging function\r\n */\r\nvar decryptContentForDir = (header, jweKeyStore, cipherText, iv, authTag, aad, log) => {\r\n  var key = null;\r\n\r\n  // try the key with the corresponding kid\r\n  if (header.kid) {\r\n    for (var i = 0; i < jweKeyStore.length; i++) {\r\n      if (header.kid === jweKeyStore[i].kid && jweKeyStore[i].kty === 'oct') {\r\n        key = jweKeyStore[i];\r\n        log.info('Decrypting JWE content, header.alg == dir, found a key matching kid: ' + header.kid);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (key)\r\n      return decryptContent(header, base64url.toBuffer(key.k), cipherText, iv, authTag, aad, log);\r\n    else\r\n      return { 'error': new Error('cannot find a key matching kid: ' + header.kid), 'cek': null };\r\n  }\r\n\r\n  log.info('In decryptContentForDir: kid is not provided in JWE header, now we try all the possible keys');\r\n\r\n  // kid matching failed, now we try every possible key\r\n  for(var i = 0; i < jweKeyStore.length; i++) {\r\n    if (jweKeyStore[i].kty === 'oct') {\r\n      var result = decryptContent(header, base64url.toBuffer(jweKeyStore[i].k), cipherText, iv, authTag, aad, log);\r\n      if (!result.error)\r\n        return result;\r\n    }\r\n  }\r\n\r\n  log.info('In decryptContentForDir: tried all keys to decrypt the content but all failed');\r\n  return { error: new Error('In decryptContentForDir: tried all keys to decrypt the content but all failed'), content_result: null };\r\n};\r\n\r\n/**\r\n * The main decryption function\r\n *\r\n * @param{String}  jweString:  JWE id_token\r\n * @param{Object}  jweKeyStore: list of keys\r\n * @return{Function}  log: logging function\r\n * @return{Function}  callback: callback function\r\n */\r\nexports.decrypt = (jweString, jweKeyStore, log, callback) => {\r\n  /****************************************************************************\r\n   *   JWE compact format structure\r\n   ****************************************************************************\r\n   * BASE64URL(UTF8(JWE Protected Header)) || '.' ||\r\n   * BASE64URL(JWE Encrypted Key) || '.' || \r\n   * BASE64URL(JWE Initialization Vector) || '.' || \r\n   * BASE64URL(JWE Ciphertext) || '.' || \r\n   * BASE64URL(JWE Authentication Tag)\r\n   ***************************************************************************/\r\n  var parts = jweString.split('.');\r\n  if (parts.length !== 5)\r\n    return callback(new Error('In jwe.decrypt: invalid JWE string, it has ' + parts.length + ' parts instead of 5'), null);\r\n  \r\n  var header;\r\n  try {\r\n    header = JSON.parse(base64url.decode(parts[0], 'binary'));\r\n  } catch (ex) {\r\n    return callback(new Error('In jwe.decrypt: failed to parse JWE header'), null);\r\n  }\r\n\r\n  var aad = createBuffer(parts[0]);\r\n  var encrypted_cek = base64url.toBuffer(parts[1]);\r\n  var iv = base64url.toBuffer(parts[2]);\r\n  var cipherText = base64url.toBuffer(parts[3]);\r\n  var authTag = base64url.toBuffer(parts[4]);\r\n\r\n  log.info('In jwe.decrypt: the header is ' + JSON.stringify(header));\r\n\r\n  var cek_result;\r\n  var content_result;\r\n\r\n  // special treatment of 'dir'\r\n  if (header.alg === 'dir') {\r\n    content_result = decryptContentForDir(header, jweKeyStore, cipherText, iv, authTag, aad, log);\r\n  } else {\r\n    /****************************************************************************\r\n     *  cek decryption\r\n     ***************************************************************************/\r\n    var cek_result = decryptCEK(header, encrypted_cek, jweKeyStore, log);\r\n    if (cek_result.error)\r\n      return callback(cek_result.error);\r\n\r\n    /****************************************************************************\r\n     *  content decryption\r\n     ***************************************************************************/\r\n    var content_result = decryptContent(header, cek_result.cek, cipherText, iv, authTag, aad, log);\r\n  }\r\n\r\n  if (!content_result.error)\r\n    log.info('In jwe.decrypt: successfully decrypted id_token');\r\n  \r\n  return callback(content_result.error, content_result.content);\r\n};\r\n\r\nexports.createBuffer = createBuffer;\r\n\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/errors/internaloautherror.js":"'use strict';\r\n\r\n/**\r\n * `InternalOAuthError` error.\r\n *\r\n * InternalOAuthError wraps errors generated by node-oauth.  By wrapping these\r\n * objects, error messages can be formatted in a manner that aids in debugging\r\n * OAuth issues.\r\n *\r\n * @api public\r\n */\r\nfunction InternalOAuthError(message, err) {\r\n  Error.call(this);\r\n  Error.captureStackTrace(this, InternalOAuthError);\r\n  this.name = 'InternalOAuthError';\r\n  this.message = message;\r\n  this.oauthError = err;\r\n}\r\n\r\n/**\r\n * Inherit from `Error`.\r\n */\r\nInternalOAuthError.prototype = Object.create(Error.prototype);\r\n\r\n/**\r\n * Returns a string representing the error.\r\n *\r\n * @return {String}\r\n * @api public\r\n */\r\nInternalOAuthError.prototype.toString = function toString() {\r\n  let m = this.message;\r\n  if (this.oauthError) {\r\n    if (this.oauthError instanceof Error) {\r\n      m += ` (${this.oauthError})`;\r\n    } else if (this.oauthError.statusCode && this.oauthError.data) {\r\n      m += `(status: ${this.oauthError.statusCode} data: ${this.oauthError.data})`;\r\n    }\r\n  }\r\n  return m;\r\n};\r\n\r\n/**\r\n * Expose `InternalOAuthError`.\r\n */\r\nmodule.exports = InternalOAuthError;\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/errors/internalopeniderror.js":"'use strict';\r\n\r\n/**\r\n * `InternalOpenIDError` error.\r\n *\r\n * InternalOpenIDError wraps errors generated by node-openid.  By wrapping these\r\n * objects, error messages can be formatted in a manner that aids in debugging\r\n * OpenID issues.\r\n *\r\n * @api public\r\n */\r\nfunction InternalOpenIDError(message, err) {\r\n  Error.call(this);\r\n  Error.captureStackTrace(this, InternalOpenIDError);\r\n  this.name = 'InternalOpenIDError';\r\n  this.message = message;\r\n  this.openidError = err;\r\n}\r\n\r\n/**\r\n * Inherit from `Error`.\r\n */\r\nInternalOpenIDError.prototype = Object.create(Error.prototype);\r\n\r\n/**\r\n * Returns a string representing the error.\r\n *\r\n * @return {String}\r\n * @api public\r\n */\r\nInternalOpenIDError.prototype.toString = function toString() {\r\n  let m = this.message;\r\n  if (this.openidError) {\r\n    if (this.openidError instanceof Error) {\r\n      m += ` (${this.openidError})`;\r\n    } else if (this.openidError.message) {\r\n      m += ` (message: '${this.openidError.message}')`;\r\n    }\r\n  }\r\n  return m;\r\n};\r\n\r\n/**\r\n * Expose `InternalOpenIDError`.\r\n */\r\nmodule.exports = InternalOpenIDError;\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/sessionContentHandler.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n'use restrict';\r\n\r\nconst aadutils = require('./aadutils');\r\n\r\n/*\r\n * the handler for state/nonce/policy\r\n * @maxAmout          - the max amount of {state: x, nonce: x, policy: x, timeStamp: x} tuples you want to save in the session\r\n * @maxAge            - when a tuple in session expires in seconds\r\n */ \r\nfunction SessionContentHandler(maxAmount, maxAge) {\r\n  if (!maxAmount || (typeof maxAmount !== 'number' || maxAmount <= 0 || maxAmount % 1 !== 0))\r\n    throw new Error('SessionContentHandler: maxAmount must be a positive integer');\r\n  if (!maxAge || (typeof maxAge !== 'number' || maxAge <= 0))\r\n    throw new Error('SessionContentHandler: maxAge must be a positive number');\r\n  this.maxAge = maxAge;  // seconds\r\n  this.maxAmount = maxAmount;\r\n}\r\n\r\nSessionContentHandler.prototype.findAndDeleteTupleByState = function(req, sessionKey, stateToFind) {\r\n  if (!req.session)\r\n    throw new Error('OIDC strategy requires session support. Did you forget to use session middleware such as express-session?');\r\n\r\n  // the array in session\r\n  var array = req.session[sessionKey] && req.session[sessionKey]['content'];\r\n  if (!array)\r\n    array = [];\r\n\r\n  // remove the expired tuples in array\r\n  aadutils.processArray(array, this.maxAmount, this.maxAge);\r\n\r\n  // find the tuple by state value\r\n  var tuple = aadutils.findAndDeleteTupleByState(array, stateToFind);\r\n\r\n  // clear empty array, and clear the session if there is nothing inside\r\n  if (req.session[sessionKey] && array.length === 0)\r\n    delete req.session[sessionKey]['content'];\r\n  if (req.session[sessionKey] && Object.keys(req.session[sessionKey]).length === 0)\r\n    delete req.session[sessionKey];\r\n\r\n  return tuple;\r\n};\r\n\r\nSessionContentHandler.prototype.add = function(req, sessionKey, tupleToAdd) {\r\n  if (!req.session)\r\n    req.session = {};\r\n  if (!req.session[sessionKey])\r\n    req.session[sessionKey] = {};\r\n  if (!req.session[sessionKey]['content'])\r\n    req.session[sessionKey]['content'] = [];\r\n\r\n  var array = req.session[sessionKey]['content'];\r\n  aadutils.processArray(array, this.maxAmount-1, this.maxAge);\r\n\r\n  array.push(tupleToAdd);\r\n};\r\n\r\nexports.SessionContentHandler = SessionContentHandler;\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/cookieContentHandler.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n'use restrict';\r\n\r\nvar crypto = require('crypto');\r\nvar createBuffer = require('./jwe').createBuffer;\r\n\r\n/*\r\n * the handler for state/nonce/policy\r\n * @maxAmount          - the max amount of {state: x, nonce: x, policy: x} tuples you want to save in cookie\r\n * @maxAge            - when a tuple in session expires in seconds\r\n * @cookieEncryptionKeys  \r\n *                    - keys used to encrypt and decrypt cookie\r\n */ \r\nfunction CookieContentHandler(maxAmount, maxAge, cookieEncryptionKeys) {\r\n  if (!maxAge || (typeof maxAge !== 'number' || maxAge <= 0))\r\n    throw new Error('CookieContentHandler: maxAge must be a positive number');\r\n  this.maxAge = maxAge;  // seconds\r\n\r\n  if (!maxAmount || (typeof maxAmount !== 'number' || maxAmount <= 0 || maxAmount % 1 !== 0))\r\n    throw new Error('CookieContentHandler: maxAmount must be a positive integer');\r\n  this.maxAmount = maxAmount;\r\n\r\n  if (!cookieEncryptionKeys || !Array.isArray(cookieEncryptionKeys) || cookieEncryptionKeys.length === 0)\r\n    throw new Error('CookieContentHandler: cookieEncryptionKeys must be a non-emptry array');\r\n\r\n  for (var i = 0; i < cookieEncryptionKeys.length; i++) {\r\n    var item = cookieEncryptionKeys[i];\r\n    if (!item.key || !item.iv)\r\n      throw new Error(`CookieContentHandler: array item ${i+1} in cookieEncryptionKeys must have the form { key: , iv: }`);\r\n    if (item.key.length !== 32)\r\n      throw new Error(`CookieContentHandler: key number ${i+1} is ${item.key.length} bytes, expected: 32 bytes`);\r\n    if (item.iv.length !== 12)\r\n      throw new Error(`CookieContentHandler: iv number ${i+1} is ${item.iv.length} bytes, expected: 12 bytes`);\r\n  }\r\n\r\n  this.cookieEncryptionKeys = cookieEncryptionKeys;\r\n}\r\n\r\nCookieContentHandler.prototype.findAndDeleteTupleByState = function(req, res, stateToFind) {\r\n  if (!req.cookies)\r\n    throw new Error('Cookie is not found in request. Did you forget to use cookie parsing middleware such as cookie-parser?');\r\n  \r\n  var cookieEncryptionKeys = this.cookieEncryptionKeys;\r\n\r\n  var tuple = null;\r\n\r\n  // try every key and every cookie\r\n  for (var i = 0; i < cookieEncryptionKeys.length; i++) {\r\n    var item = cookieEncryptionKeys[i];\r\n    var key = createBuffer(item.key);\r\n    var iv = createBuffer(item.iv);\r\n\r\n    for (var cookie in req.cookies) {     \r\n      if (req.cookies.hasOwnProperty(cookie) && cookie.startsWith('passport-aad.')) {\r\n        var encrypted = cookie.substring(13);\r\n\r\n        try {\r\n          var decrypted = decryptCookie(encrypted, key, iv);\r\n          tuple = JSON.parse(decrypted);\r\n        } catch (ex) {\r\n          continue;\r\n        }\r\n\r\n        if (tuple.state === stateToFind) {\r\n          res.clearCookie(cookie);\r\n          return tuple;      \r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nCookieContentHandler.prototype.add = function(req, res, tupleToAdd) {\r\n  var cookies = [];\r\n\r\n  // collect the related cookies\r\n  for (var cookie in req.cookies) {     \r\n    if (req.cookies.hasOwnProperty(cookie) && cookie.startsWith('passport-aad.'))\r\n      cookies.push(cookie);\r\n  }\r\n\r\n  // only keep the most recent maxAmount-1 many cookies\r\n  if (cookies.length > this.maxAmount - 1) {\r\n    cookies.sort();\r\n\r\n    var numberToRemove = cookies.length - (this.maxAmount - 1);\r\n\r\n    for (var i = 0; i < numberToRemove; i++) {\r\n      res.clearCookie(cookies[0]);\r\n      cookies.shift();\r\n    }\r\n  }\r\n\r\n  // add the new cookie\r\n\r\n  var tupleString = JSON.stringify(tupleToAdd);\r\n\r\n  var item = this.cookieEncryptionKeys[0];\r\n  var key = createBuffer(item.key);\r\n  var iv = createBuffer(item.iv);\r\n\r\n  var encrypted = encryptCookie(tupleString, key, iv);\r\n\r\n  res.cookie('passport-aad.' + Date.now() + '.' + encrypted, 0, { maxAge: this.maxAge * 1000, httpOnly: true });\r\n};\r\n\r\nvar encryptCookie = function(content, key, iv) {\r\n  var cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\r\n\r\n  var encrypted = cipher.update(content, 'utf8', 'hex');\r\n  encrypted += cipher.final('hex');\r\n  var authTag = cipher.getAuthTag().toString('hex');\r\n\r\n  return encrypted + '.' + authTag;\r\n};\r\n\r\nvar decryptCookie = function(encrypted, key, iv) {\r\n  var parts = encrypted.split('.');\r\n  if (parts.length !== 3)\r\n    throw new Error('invalid cookie');\r\n\r\n  // the first part is timestamp, ignore it\r\n  var content = createBuffer(parts[1], 'hex');\r\n  var authTag = createBuffer(parts[2], 'hex');\r\n\r\n  var decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);\r\n  decipher.setAuthTag(authTag);\r\n  var decrypted = decipher.update(content, 'hex', 'utf8');\r\n  decrypted +=  decipher.final('utf8');\r\n\r\n  return decrypted;\r\n};\r\n\r\nexports.CookieContentHandler = CookieContentHandler;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/lib/validator.js":"/**\r\n * Copyright (c) Microsoft Corporation\r\n *  All Rights Reserved\r\n *  MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\r\n * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\r\n * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n'use strict';\r\n\r\nconst UrlValidator = require('valid-url');\r\n\r\nconst types = {};\r\n\r\nfunction Validator(config) {\r\n  this.config = config;\r\n}\r\n\r\nValidator.prototype.validate = function validate(options) {\r\n  const opts = options || {};\r\n\r\n  Object.keys(this.config).forEach((item) => {\r\n    if (!this.config.hasOwnProperty(item)) {\r\n      throw new TypeError(`Missing value for ${item}`);\r\n    }\r\n    const type = this.config[item];\r\n    if (!type) {\r\n      return; // no need to validate\r\n    }\r\n    const checker = types[type];\r\n    if (!checker) { // missing required checker\r\n      throw new TypeError(`No handler to validate type ${type} for item ${item}`);\r\n    }\r\n\r\n    if (!checker.validate(opts[item])) {\r\n      throw new TypeError(`Invalid value for ${item}.${checker.error}`);\r\n    }\r\n  });\r\n};\r\n\r\nValidator.isNonEmpty = 'isNonEmpty';\r\ntypes.isNonEmpty = {\r\n  validate: (value) => {\r\n    return value !== '' && value !== undefined && value !== null;\r\n  },\r\n  error: 'The value cannot be empty',\r\n};\r\n\r\nValidator.isTypeLegal = 'isTypeLegal';\r\ntypes.isTypeLegal = {\r\n  validate: (value) => {\r\n    return value === 'id_token' || value === 'id_token code' || value === 'code id_token' || value === 'code';\r\n  },\r\n  error: 'The responseType: must be either id_token, id_token code, code id_token or code.',\r\n};\r\n\r\nValidator.isModeLegal = 'isModeLegal';\r\ntypes.isModeLegal = {\r\n  validate: (value) => {\r\n    return value === 'query' || value === 'form_post';\r\n  },\r\n  error: 'The responseMode: must be either query or form_post.',\r\n};\r\n\r\nValidator.isURL = 'isURL';\r\ntypes.isURL = {\r\n  validate: (value) => {\r\n    return UrlValidator.isHttpUri(value) || UrlValidator.isHttpsUri(value);\r\n  },\r\n  error: 'The URL must be valid and be https:// or http://',\r\n};\r\n\r\nValidator.isHttpURL = 'isHttpURL';\r\ntypes.isHttpURL = {\r\n  validate: (value) => {\r\n    return UrlValidator.isHttpUri(value);\r\n  },\r\n  error: 'The URL must be valid and be http://',\r\n};\r\n\r\nValidator.isHttpsURL = 'isHttpsURL';\r\ntypes.isHttpsURL = {\r\n  validate: (value) => {\r\n    return UrlValidator.isHttpsUri(value);\r\n  },\r\n  error: 'The URL must be valid and be https://',\r\n};\r\n\r\nValidator.isHttpsURLIfExists = 'isHttpsURLIfExists';\r\ntypes.isHttpsURLIfExists = {\r\n  validate: (value) => {\r\n    if (value)\r\n      return UrlValidator.isHttpsUri(value);\r\n    else\r\n      return true;\r\n  },\r\n  error: 'The URL must be valid and be https://',\r\n};\r\n\r\nexports.Validator = Validator;\r\n","/home/travis/build/npmtest/node-npmtest-passport-azure-ad/node_modules/passport-azure-ad/Gruntfile.js":"'use strict';\r\n\r\nmodule.exports = function loadGrunt(grunt) {\r\n  // Project configuration.\r\n  grunt.initConfig({\r\n    pkg: grunt.file.readJSON('package.json'),\r\n    nodeunit: {\r\n      files: ['test/Nodeunit_test/*_test.js'],\r\n    },\r\n    mochaTest: {\r\n      test: {\r\n        options: {\r\n          reporter: 'spec',\r\n          clearRequireCache: true\r\n        },\r\n        src: ['test/Chai-passport_test/*_test.js'],\r\n      },\r\n    },\r\n    eslint: {\r\n      options: {},\r\n      gruntfile: {\r\n        src: 'Gruntfile.js',\r\n      },\r\n      lib: {\r\n        src: ['lib/**/*.js'],\r\n      },\r\n      examples: {\r\n        src: ['examples/*/*.js'],\r\n      },\r\n      test: {\r\n        src: ['test/**/*.js'],\r\n      },\r\n    },\r\n    watch: {\r\n      gruntfile: {\r\n        files: '<%= eslint.gruntfile.src %>',\r\n        tasks: ['eslint:gruntfile'],\r\n      },\r\n      lib: {\r\n        files: '<%= eslint.lib.src %>',\r\n        tasks: ['eslint:lib', 'nodeunit', 'mochaTest'],\r\n      },\r\n      test: {\r\n        files: '<%= eslint.test.src %>',\r\n        tasks: ['eslint:test', 'nodeunit', 'mochaTest'],\r\n      },\r\n    },\r\n  });\r\n\r\n  // These plugins provide necessary tasks.\r\n  grunt.loadNpmTasks('grunt-contrib-nodeunit');\r\n  grunt.loadNpmTasks('grunt-eslint');\r\n  grunt.loadNpmTasks('grunt-contrib-watch');\r\n  grunt.loadNpmTasks('grunt-mocha-test');\r\n\r\n  grunt.registerTask('printMsg_nodeunit', () => {\r\n    grunt.log.writeln('\\n\\n\\n======= Running tests in test/nodeunit_test =======\\n\\n\\n');\r\n  });\r\n  grunt.registerTask('printMsg_chai-passport', () => {\r\n    grunt.log.writeln('\\n\\n\\n======= Running tests in test/chai-passport_test =======\\n\\n\\n');\r\n  });\r\n  grunt.registerTask('printMsg_end_to_end_Test', () => {\r\n    grunt.log.writeln('\\n\\n\\n======= Running end to end tests in test/End_to_end_test =======\\n\\n\\n');\r\n  });\r\n  grunt.registerTask('end_to_end_test', () => {\r\n    grunt.config('mochaTest.test.src', 'test/End_to_end_test/*_test.js');\r\n    grunt.task.run(['mochaTest']);\r\n  });\r\n  grunt.registerTask('e2e', ['printMsg_end_to_end_Test', 'end_to_end_test']);\r\n  grunt.registerTask('run_tests_with_e2e', ['printMsg_chai-passport', 'mochaTest', 'printMsg_nodeunit', 'nodeunit', 'printMsg_end_to_end_Test', 'end_to_end_test']);\r\n  grunt.registerTask('run_tests', ['printMsg_chai-passport', 'mochaTest', 'printMsg_nodeunit', 'nodeunit']);  \r\n  grunt.registerTask('default', 'run_tests');\r\n};\r\n"}